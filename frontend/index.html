<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Bar-iton - Tiefling Barde Charakterbogen</title>
    <link rel="stylesheet" href="/css/styles.css">
</head>
<body>
    <script>
        // Login erzwingen und nach Login letzten gespielten Charakter laden
        (async function enforceLoginAndAutoload() {
            try {
                const res = await fetch('/backend/api/auth.php', { credentials: 'include' });
                const user = await res.json();
                if (!user || !user.id) {
                    const redirect = encodeURIComponent(location.pathname);
                    location.href = `/login.html?redirect=${redirect}`;
                    return;
                }
                // Admin oder User: lade Liste und versuche letzten Snapshot zu finden
                if (window.apiClient && typeof window.apiClient.getAllCharacters === 'function') {
                    const chars = await window.apiClient.getAllCharacters();
                    // Finde j√ºngsten Snapshot √ºber alle sichtbaren Charaktere
                    let latest = { date: null, id: null };
                    for (const c of chars) {
                        try {
                            const resp = await fetch(`/backend/api/sessions.php?character_id=${c.id}&latest_snapshot=true`, { credentials: 'include' });
                            if (resp.ok) {
                                const snap = await resp.json();
                                const d = new Date(snap.created_at);
                                if (!latest.date || d > latest.date) {
                                    latest = { date: d, id: c.id };
                                }
                            }
                        } catch {}
                    }
                    // Wenn gefunden, lade diesen Character, sonst fallback: ersten Character oder Template
                    if (latest.id) {
                        if (typeof window.initCharacterManager === 'function') window.initCharacterManager(latest.id);
                        if (typeof window.loadCharacter === 'function') await window.loadCharacter(latest.id);
                    } else if (chars && chars.length > 0) {
                        const firstId = chars[0].id;
                        if (typeof window.initCharacterManager === 'function') window.initCharacterManager(firstId);
                        if (typeof window.loadCharacter === 'function') await window.loadCharacter(firstId);
                    } else {
                        // Keine Charaktere vorhanden: Template initialisieren
                        if (typeof window.initDefaultCharacter === 'function') window.initDefaultCharacter();
                    }
                }
            } catch (e) {
                const redirect = encodeURIComponent(location.pathname);
                location.href = `/login.html?redirect=${redirect}`;
            }
        })();
    </script>
    <div class="container">
        <!-- Character Selection -->
        <div class="character-selector" style="margin-bottom: 20px; padding: 15px; background: rgba(139, 0, 0, 0.3); border-radius: 10px; border: 2px solid rgba(255, 215, 0, 0.5);">
            <div style="display: flex; align-items: center; justify-content: space-between; flex-wrap: wrap; gap: 15px;">
                <div style="display: flex; align-items: center; gap: 10px; flex: 1; min-width: 200px;">
                    <label style="color: #ffcccc; font-weight: 500;">Charakter:</label>
                    <select id="characterSelect" style="flex: 1; padding: 8px 12px; background: rgba(0,0,0,0.5); border: 2px solid rgba(255,215,0,0.6); border-radius: 8px; color: #ffd700; font-size: 1em; cursor: pointer; min-width: 200px;" onchange="switchCharacter()">
                        <option value="">Lade Charaktere...</option>
                    </select>
                </div>
                <div style="display: flex; gap: 10px; flex-wrap: wrap;">
                    <button class="nav-btn" onclick="showCreateCharacterModal()" style="background: linear-gradient(135deg, #4a90e2, #357abd);">‚ûï Neuer Charakter</button>
                    <button class="nav-btn" onclick="refreshCharacterList()" style="background: linear-gradient(135deg, #2ecc71, #27ae60);">üîÑ Aktualisieren</button>
                </div>
            </div>
            <!-- Session Management -->
            <div style="margin-top: 15px; padding-top: 15px; border-top: 1px solid rgba(255, 215, 0, 0.3);">
                <div style="display: flex; align-items: center; gap: 10px; flex-wrap: wrap;">
                    <label style="color: #ffcccc; font-weight: 500;">Session:</label>
                    <span id="sessionStatus" style="color: #aaa; font-style: italic;">Keine aktive Session</span>
                    <button id="startSessionBtn" class="nav-btn" onclick="startSession()" style="background: linear-gradient(135deg, #2ecc71, #27ae60);">‚ñ∂Ô∏è Session starten</button>
                    <button id="endSessionBtn" class="nav-btn" onclick="endSession()" style="background: linear-gradient(135deg, #e74c3c, #c0392b); display: none;">‚èπÔ∏è Session beenden</button>
                    <button id="createSnapshotBtn" class="nav-btn" onclick="createSnapshot()" style="background: linear-gradient(135deg, #9b59b6, #8e44ad);">üì∏ Screenshot erstellen</button>
                </div>
            </div>
        </div>

        <!-- Navigation -->
        <div class="page-nav">
            <button class="nav-btn active" onclick="showPage('overview')">üìã √úbersicht</button>
            <button class="nav-btn" onclick="showPage('combat')">‚öîÔ∏è Kampf</button>
            <button class="nav-btn" onclick="showPage('spells')">‚ú® Zauber</button>
            <button class="nav-btn" onclick="showPage('inventory')">üéí Inventar</button>
            <button class="nav-btn" onclick="showPage('rules')">üé≤ Spielregeln</button>
            <button class="nav-btn" onclick="showPage('notes')">üìù Notizen</button>
        </div>

        <!-- Header mit Charakterbild -->
        <div class="header">
            <div class="portrait-container">
                <div class="character-portrait">
                    <img id="characterImage" src="/images/Bariton_ziv.png" alt="Bar-iton">
                </div>
                <button class="portrait-toggle" onclick="togglePortrait()">üé≠ Wechseln</button>
            </div>
            <div class="header-info">
                <div style="display: flex; justify-content: space-between; align-items: flex-start; gap: 20px;">
                    <div style="flex: 1;">
                        <h1><span id="characterName" class="max-value">Bar-iton</span> <span class="level-badge">Level <span id="charLevel" class="max-value">1</span></span></h1>
                        <div class="subtitle" id="characterSubtitle">Tiefling Barde ‚Ä¢ Chthonische Abstammung ‚Ä¢ Chaotic Neutral</div>
                    </div>
                    <button id="editModeToggle" class="nav-btn" onclick="toggleEditMode()" style="background: linear-gradient(135deg, #9e9e9e, #757575); padding: 10px 20px; font-size: 0.95em; white-space: nowrap;">
                        ‚úèÔ∏è Bearbeitungsmodus: <span id="editModeStatus">AUS</span>
                    </button>
                </div>
                <div class="quick-stats">
                    <div class="quick-stat">
                        <div class="quick-stat-label">Trefferpunkte</div>
                        <div class="quick-stat-value">
                            <button class="btn-small-inline" onclick="adjustQuickHP(-1)" title="-1 HP">-</button>
                            <span id="currentHP" class="editable">9</span>/<span id="maxHP" class="max-value">9</span>
                            <button class="btn-small-inline" onclick="adjustQuickHP(1)" title="+1 HP">+</button>
                        </div>
                        <div class="quick-stat-temp" style="margin-top: 6px; font-size: 0.75em; color: #88dd88;">
                            Temp: <span id="tempHP" class="editable-small">0</span>
                            <button class="btn-small-inline" style="font-size: 0.7em; padding: 2px 6px; min-width: 24px; height: 24px;" onclick="adjustTempHP(-1)">-</button>
                            <button class="btn-small-inline" style="font-size: 0.7em; padding: 2px 6px; min-width: 24px; height: 24px;" onclick="adjustTempHP(1)">+</button>
                        </div>
                    </div>
                    <div class="quick-stat">
                        <div class="quick-stat-label">R√ºstungsklasse</div>
                        <div class="quick-stat-value" id="armorClassDisplay">15</div>
                    </div>
                    <div class="quick-stat">
                        <div class="quick-stat-label">Bardische Insp.</div>
                        <div class="quick-stat-value">
                            <span id="currentBI" class="editable">2</span>/<span id="maxBI" class="max-value">3</span>
                        </div>
                    </div>
                    <div class="quick-stat">
                        <div class="quick-stat-label">Ge√ºbtheitsbonus</div>
                        <div class="quick-stat-value">+<span id="profBonus" class="max-value">2</span></div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Page 1: Overview -->
        <div id="overview" class="page active">
            <div class="card">
                <h2>üìà Erfahrung & Level</h2>
                <div class="resource-tracker">
                    <span class="resource-label">Erfahrungspunkte:</span>
                    <div class="resource-controls">
                        <button class="btn-small" onclick="adjustXP(-10)">-10</button>
                        <span class="editable" id="currentXP">0</span>
                        <span>/</span>
                        <span id="nextLevelXP">300</span>
                        <button class="btn-small" onclick="adjustXP(10)">+10</button>
                        <button class="btn-small" onclick="adjustXP(100)" style="margin-left: 10px;">+100</button>
                    </div>
                </div>
                <div class="xp-bar">
                    <div class="xp-fill" id="xpBar" style="width: 0%;">0%</div>
                </div>
                <div style="margin-top: 15px; display: flex; gap: 10px;">
                    <button class="btn-level-down" onclick="undoLevelUp()" title="Level-Up r√ºckg√§ngig machen">
                        ‚¨áÔ∏è Level-Up r√ºckg√§ngig
                    </button>
                </div>
            </div>

            <div class="card" style="margin-top: 20px;">
                <h2>üõå Rasten</h2>
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px; margin-top: 15px;">
                    <button class="btn-rest" onclick="takeShortRest()" style="background: linear-gradient(145deg, #4caf50, #388e3c);">
                        <strong>‚è±Ô∏è Kurze Rast</strong>
                        <div style="font-size: 0.85em; margin-top: 5px; opacity: 0.9;">1 Stunde - Trefferw√ºrfel zur Heilung</div>
                    </button>
                    <button class="btn-rest" onclick="takeLongRest()" style="background: linear-gradient(145deg, #2196f3, #1976d2);">
                        <strong>üåô Lange Rast</strong>
                        <div style="font-size: 0.85em; margin-top: 5px; opacity: 0.9;">8 Stunden - Vollst√§ndige Regeneration</div>
                    </button>
                </div>
            </div>

            <div class="grid-2">
                <div class="card">
                    <h2>üìä Attribute</h2>
                    <div class="stats-grid">
                        <div class="stat-box">
                            <div class="stat-name">STR</div>
                            <div class="stat-value" id="statSTR" data-stat="str" contenteditable="false">8</div>
                            <div class="stat-modifier" id="modSTR">-1</div>
                        </div>
                        <div class="stat-box">
                            <div class="stat-name">GES</div>
                            <div class="stat-value" id="statDEX" data-stat="dex" contenteditable="false">15</div>
                            <div class="stat-modifier" id="modDEX">+2</div>
                        </div>
                        <div class="stat-box">
                            <div class="stat-name">KON</div>
                            <div class="stat-value" id="statCON" data-stat="con" contenteditable="false">12</div>
                            <div class="stat-modifier" id="modCON">+1</div>
                        </div>
                        <div class="stat-box">
                            <div class="stat-name">INT</div>
                            <div class="stat-value" id="statINT" data-stat="int" contenteditable="false">13</div>
                            <div class="stat-modifier" id="modINT">+1</div>
                        </div>
                        <div class="stat-box">
                            <div class="stat-name">WEI</div>
                            <div class="stat-value" id="statWIS" data-stat="wis" contenteditable="false">10</div>
                            <div class="stat-modifier" id="modWIS">+0</div>
                        </div>
                        <div class="stat-box">
                            <div class="stat-name">CHA</div>
                            <div class="stat-value" id="statCHA" data-stat="cha" contenteditable="false">17</div>
                            <div class="stat-modifier" id="modCHA">+3</div>
                        </div>
                    </div>
                </div>

                <div class="card">
                    <h2>üéØ Fertigkeiten</h2>
                    <div>
                        <span class="skill-badge">Akrobatik +4</span>
                        <span class="skill-badge">Auftreten +5</span>
                        <span class="skill-badge">T√§uschung +5</span>
                        <span class="skill-badge">√úberzeugen +5</span>
                        <span class="skill-badge">Fingerfertigkeit +4</span>
                        <span class="skill-badge">Heimlichkeit +2</span>
                    </div>
                    <h3 style="margin-top: 20px; color: #ffb3b3;">Sprachen</h3>
                    <div>
                        <span class="skill-badge">Gemeinsprache</span>
                        <span class="skill-badge">Zeichensprache</span>
                        <span class="skill-badge">Gnomisch</span>
                    </div>
                    <h3 style="margin-top: 20px; color: #ffb3b3;">Ge√ºbtheiten</h3>
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px; margin-top: 10px;">
                        <div>
                            <h4 style="color: #ffcccc; margin-bottom: 8px; font-size: 0.95em;">R√ºstungen:</h4>
                            <div style="color: #f0f0f0; font-size: 0.9em;">Leichte R√ºstung</div>
                        </div>
                        <div>
                            <h4 style="color: #ffcccc; margin-bottom: 8px; font-size: 0.95em;">Waffen:</h4>
                            <div style="color: #f0f0f0; font-size: 0.9em;">Einfache Waffen, Handwaffen, Langschwerter, Rapier, Kurzschwerter</div>
                        </div>
                        <div>
                            <h4 style="color: #ffcccc; margin-bottom: 8px; font-size: 0.95em;">Werkzeuge:</h4>
                            <div style="color: #f0f0f0; font-size: 0.9em;">Musikinstrumente (Laute, Fl√∂te, Lyra)</div>
                        </div>
                        <div>
                            <h4 style="color: #ffcccc; margin-bottom: 8px; font-size: 0.95em;">Rettungsw√ºrfe:</h4>
                            <div style="color: #f0f0f0; font-size: 0.9em;">Geschicklichkeit, Charisma</div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="card">
                <h2>üé≠ Pers√∂nlichkeit & Hintergrund</h2>
                <div class="grid-2">
                    <div>
                        <h3>Merkmale</h3>
                        <ul style="margin-left: 20px; line-height: 1.8;">
                            <li>Elternteil war ber√ºhmter Geschichtenerz√§hler</li>
                            <li>Stotternde Stimme</li>
                        </ul>
                    </div>
                    <div>
                        <h3>Ideal</h3>
                        <p>L√ºgen k√∂nnen Wahrheiten enth√ºllen</p>
                    </div>
                    <div>
                        <h3>Bindung</h3>
                        <p>Viele Fans unter den Orks</p>
                    </div>
                    <div>
                        <h3>Makel</h3>
                        <p>R√ºcksichtslos beim Streben nach Ruhm</p>
                    </div>
                </div>
            </div>
        </div>

        <!-- Page 2: Combat -->
        <div id="combat" class="page">
            <div class="grid-2">
                <div class="card">
                    <h2>‚öîÔ∏è Waffen & Angriffe</h2>
                    <table id="weaponsTable">
                        <thead>
                            <tr>
                                <th>Waffe/Angriff</th>
                                <th>Bonus</th>
                                <th>Schaden</th>
                                <th>Reichweite</th>
                            </tr>
                        </thead>
                        <tbody id="weaponsTableBody">
                            <tr id="mainHandWeapon">
                                <td>-</td>
                                <td>-</td>
                                <td>-</td>
                                <td>-</td>
                            </tr>
                            <tr id="offHandWeapon" style="display: none;">
                                <td>-</td>
                                <td>-</td>
                                <td>-</td>
                                <td>-</td>
                            </tr>
                        </tbody>
                    </table>
                    
                    <h3 style="margin-top: 20px; color: #ffcccc; border-bottom: 2px solid rgba(255,107,107,0.5); padding-bottom: 10px;">‚ú® Zauber (Kampf)</h3>
                    <div id="combatSpellsList" style="display: grid; gap: 10px; margin-top: 15px;">
                        <!-- Zaubertricks (Cantrips) - keine Slots n√∂tig -->
                        <div class="combat-spell-item" data-spell-type="cantrip" data-spell-name="Boshafter Spott" data-save-dc="13" data-damage="1W4 psychisch" data-range="18m">
                            <div class="combat-spell-header">
                                <strong style="color: #ba68c8;">üé≠ Boshafter Spott</strong>
                                <button class="btn-cast-spell" onclick="castSpell(this)" title="Zaubertrick - Keine Slots n√∂tig">Zaubern</button>
                            </div>
                            <div class="combat-spell-details">SG 13 WEI | <strong>Schaden:</strong> 1W4 psychisch | <strong>Reichweite:</strong> 18m</div>
                        </div>
                        <div class="combat-spell-item" data-spell-type="cantrip" data-spell-name="K√§ltegriff" data-damage="1W8 nekrotisch" data-range="36m">
                            <div class="combat-spell-header">
                                <strong style="color: #ba68c8;">üíÄ K√§ltegriff</strong>
                                <button class="btn-cast-spell" onclick="castSpell(this)" title="Zaubertrick - Keine Slots n√∂tig">Zaubern</button>
                            </div>
                            <div class="combat-spell-details"><strong>Schaden:</strong> 1W8 nekrotisch | <strong>Reichweite:</strong> 36m</div>
                        </div>
                        
                        <!-- 1. Grad Zauber - ben√∂tigen Slots -->
                        <div class="combat-spell-item" data-spell-type="1" data-spell-name="Person bezaubern" data-save-dc="13" data-range="9m">
                            <div class="combat-spell-header">
                                <strong style="color: #ff5252;">üíñ Person bezaubern</strong>
                                <button class="btn-cast-spell" onclick="castSpell(this)" title="1. Grad - Verbraucht 1 Zauberplatz">Zaubern (1. Grad)</button>
                            </div>
                            <div class="combat-spell-details">SG 13 WEI | <strong>Effekt:</strong> Ziel sieht dich als freundlichen Bekannten | <strong>Reichweite:</strong> 9m</div>
                        </div>
                        <div class="combat-spell-item" data-spell-type="1" data-spell-name="Farbspray" data-range="4,5m Kegel">
                            <div class="combat-spell-header">
                                <strong style="color: #ff5252;">üåà Farbspray</strong>
                                <button class="btn-cast-spell" onclick="castSpell(this)" title="1. Grad - Verbraucht 1 Zauberplatz">Zaubern (1. Grad)</button>
                            </div>
                            <div class="combat-spell-details"><strong>Effekt:</strong> Blenden (betrifft 6W10 TP) | <strong>Reichweite:</strong> 4,5m Kegel</div>
                        </div>
                        <div class="combat-spell-item" data-spell-type="1" data-spell-name="Dissonantes Fl√ºstern" data-save-dc="13" data-damage="3W6 psychisch" data-range="18m">
                            <div class="combat-spell-header">
                                <strong style="color: #ff5252;">üé∂ Dissonantes Fl√ºstern</strong>
                                <button class="btn-cast-spell" onclick="castSpell(this)" title="1. Grad - Verbraucht 1 Zauberplatz">Zaubern (1. Grad)</button>
                            </div>
                            <div class="combat-spell-details">SG 13 WEI | <strong>Schaden:</strong> 3W6 psychisch (halber bei Rettung) | <strong>Reichweite:</strong> 18m</div>
                        </div>
                        <div class="combat-spell-item" data-spell-type="bonus" data-spell-name="Heilendes Wort" data-healing="1W4+3" data-range="18m">
                            <div class="combat-spell-header">
                                <strong style="color: #4caf50;">üíö Heilendes Wort</strong>
                                <button class="btn-cast-spell" onclick="castSpell(this)" title="1. Grad BONUSAKTION - Verbraucht 1 Zauberplatz">Zaubern (Bonusaktion)</button>
                            </div>
                            <div class="combat-spell-details"><strong>Heilung:</strong> 1W4+3 | <strong>Reichweite:</strong> 18m | <strong>BONUSAKTION!</strong></div>
                        </div>
                    </div>
                    
                    <div style="margin-top: 20px; padding: 12px; background: rgba(255,215,0,0.15); border: 2px solid rgba(255,215,0,0.4); border-radius: 8px;">
                        <h4 style="color: #ffeb3b; margin-bottom: 10px;">‚ö° Bonusaktionen</h4>
                        <button class="btn-bardic-inspiration" onclick="useBardicInspiration()" id="bardicInspirationBtn">
                            üéµ Bardische Inspiration geben (W6)
                        </button>
                        <div style="margin-top: 8px; font-size: 0.9em; color: #ffcccc;">
                            Verf√ºgbar: <span id="currentBICombat" style="color: #ffeb3b; font-weight: bold;">2</span>/3
                        </div>
                    </div>
                </div>

                <div class="card">
                    <h2>üõ°Ô∏è Verteidigung</h2>
                    <table>
                        <tr>
                            <td><strong>R√ºstungsklasse</strong></td>
                            <td>15 (10 + GES + CHA)</td>
                        </tr>
                        <tr>
                            <td><strong>Initiative</strong></td>
                            <td>+2</td>
                        </tr>
                        <tr>
                            <td><strong>Bewegung</strong></td>
                            <td>9 Meter</td>
                        </tr>
                        <tr>
                            <td><strong>Passive Wahrnehmung</strong></td>
                            <td>10</td>
                        </tr>
                    </table>
                    <h3>Rettungsw√ºrfe (Ge√ºbt)</h3>
                    <ul style="margin-left: 20px;">
                        <li>Geschicklichkeit: +4 ‚úì</li>
                        <li>Charisma: +5 ‚úì</li>
                    </ul>
                </div>
            </div>

            <div class="card">
                <h2>üíÄ Todesrettungsw√ºrfe</h2>
                <div style="display: flex; gap: 30px; align-items: center;">
                    <div>
                        <span style="color: #4caf50;">Erfolge:</span>
                        <label><input type="checkbox" id="death1s"> ‚óã</label>
                        <label><input type="checkbox" id="death2s"> ‚óã</label>
                        <label><input type="checkbox" id="death3s"> ‚óã</label>
                    </div>
                    <div>
                        <span style="color: #ff4444;">Misserfolge:</span>
                        <label><input type="checkbox" id="death1f"> ‚óã</label>
                        <label><input type="checkbox" id="death2f"> ‚óã</label>
                        <label><input type="checkbox" id="death3f"> ‚óã</label>
                    </div>
                    <button class="btn-small green" onclick="resetDeathSaves()">‚Üª Reset</button>
                </div>
            </div>
        </div>

        <!-- Page 3: Spells -->
        <div id="spells" class="page">
            <div class="card">
                <h2>‚ú® Zauberressourcen</h2>
                <div style="margin-bottom: 20px; word-wrap: break-word; overflow-wrap: break-word;">
                    <strong style="color: #ffd700;">Zauberangriffsmodifikator:</strong> +5 | 
                    <strong style="color: #ffd700;">Zauber-SG:</strong> 13 |
                    <strong style="color: #ffd700;">Zauberattribut:</strong> Charisma
                </div>
                
                <h3 style="color: #9d4edd;">Zauberpl√§tze Grad 1</h3>
                <div class="spell-slots">
                    <div class="spell-slot" onclick="toggleSpellSlot(this)"></div>
                    <div class="spell-slot" onclick="toggleSpellSlot(this)"></div>
                    <button class="btn-small" onclick="resetSpellSlots()">‚Üª Reset</button>
                </div>
            </div>

            <div class="card">
                <h2>üéØ Zaubertricks (beliebig oft)</h2>
                
                <div class="spell-card">
                    <div class="spell-name">üé≠ Boshafter Spott (Vicious Mockery)</div>
                    <div class="spell-type">Verzauberung-Zaubertrick ‚Ä¢ Barde</div>
                    <div>
                        <strong>Reichweite:</strong> 18 Meter<br>
                        <strong>Komponenten:</strong> V (Verbal)<br>
                        <strong>Schaden:</strong> 1W4 psychisch (steigt mit Level)<br>
                        <strong>Effekt:</strong> WEI-Rettungswurf SG 13 oder Nachteil auf n√§chsten Angriff vor Ende des n√§chsten Zugs
                    </div>
                </div>

                <div class="spell-card">
                    <div class="spell-name">üí° Tanzende Lichter (Dancing Lights)</div>
                    <div class="spell-type">Hervorrufung-Zaubertrick ‚Ä¢ Barde</div>
                    <div>
                        <strong>Reichweite:</strong> 36 Meter<br>
                        <strong>Komponenten:</strong> V, S, M (Phosphor oder Gl√ºhw√ºrmchen)<br>
                        <strong>Dauer:</strong> Konzentration, bis zu 1 Minute<br>
                        <strong>Effekt:</strong> Bis zu 4 schwebende Lichtkugeln (Fackel-Helligkeit), bewegbar als Bonusaktion
                    </div>
                </div>

                <div class="spell-card">
                    <div class="spell-name">üíÄ K√§ltegriff (Chill Touch)</div>
                    <div class="spell-type">Nekromantie-Zaubertrick ‚Ä¢ Tiefling-Merkmal</div>
                    <div>
                        <strong>Reichweite:</strong> 36 Meter<br>
                        <strong>Komponenten:</strong> V, S<br>
                        <strong>Schaden:</strong> 1W8 nekrotisch (steigt mit Level)<br>
                        <strong>Effekt:</strong> Skeletthand verhindert Heilung bis zu deinem n√§chsten Zug
                    </div>
                </div>

                <div class="spell-card">
                    <div class="spell-name">üîÆ Thaumaturgie (Thaumaturgy)</div>
                    <div class="spell-type">Verwandlung-Zaubertrick ‚Ä¢ Tiefling-Merkmal</div>
                    <div>
                        <strong>Reichweite:</strong> 9 Meter<br>
                        <strong>Komponenten:</strong> V<br>
                        <strong>Dauer:</strong> Bis zu 1 Minute<br>
                        <strong>Effekte:</strong> 
                        <ul style="margin-left: 20px; margin-top: 5px;">
                            <li>Stimme 3x lauter</li>
                            <li>Flammen flackern/Farbe √§ndern</li>
                            <li>Harmlose Ersch√ºtterungen</li>
                            <li>Ger√§usche erzeugen</li>
                            <li>T√ºren/Fenster √∂ffnen/schlie√üen</li>
                            <li>Augenfarbe √§ndern</li>
                        </ul>
                    </div>
                </div>
            </div>

            <div class="card">
                <h2>üìñ Zauber des 1. Grades (4 vorbereitet)</h2>
                
                <div class="spell-card">
                    <div class="spell-name">üíñ Person bezaubern (Charm Person)</div>
                    <div class="spell-type">Verzauberung ‚Ä¢ 1. Grad</div>
                    <div>
                        <strong>Zeitaufwand:</strong> 1 Aktion<br>
                        <strong>Reichweite:</strong> 9 Meter<br>
                        <strong>Komponenten:</strong> V, S<br>
                        <strong>Dauer:</strong> 1 Stunde<br>
                        <strong>Effekt:</strong> Humanoide mit WEI-Rettungswurf. Bei Misserfolg: Ziel sieht dich als freundlichen Bekannten. Vorteil bei Rettungswurf wenn du/Gef√§hrten k√§mpfen.
                    </div>
                </div>

                <div class="spell-card">
                    <div class="spell-name">üåà Farbspray (Color Spray)</div>
                    <div class="spell-type">Illusion ‚Ä¢ 1. Grad</div>
                    <div>
                        <strong>Zeitaufwand:</strong> 1 Aktion<br>
                        <strong>Reichweite:</strong> Selbst (4,5 Meter Kegel)<br>
                        <strong>Komponenten:</strong> V, S, M (Sand in drei Farben)<br>
                        <strong>Dauer:</strong> 1 Runde<br>
                        <strong>Effekt:</strong> Betrifft 6W10 TP an Kreaturen (aufsteigend nach TP). Betroffene sind blind bis Ende deines n√§chsten Zugs.
                    </div>
                </div>

                <div class="spell-card">
                    <div class="spell-name">üé∂ Dissonantes Fl√ºstern (Dissonant Whispers)</div>
                    <div class="spell-type">Verzauberung ‚Ä¢ 1. Grad</div>
                    <div>
                        <strong>Zeitaufwand:</strong> 1 Aktion<br>
                        <strong>Reichweite:</strong> 18 Meter<br>
                        <strong>Komponenten:</strong> V<br>
                        <strong>Schaden:</strong> 3W6 psychisch (halber bei erfolgreicher Rettung)<br>
                        <strong>Effekt:</strong> WEI-Rettungswurf. Bei Misserfolg: Muss Reaktion nutzen um sich wegzubewegen (provoziert Gelegenheitsangriffe!)
                    </div>
                </div>

                <div class="spell-card">
                    <div class="spell-name">üíö Heilendes Wort (Healing Word)</div>
                    <div class="spell-type">Hervorrufung ‚Ä¢ 1. Grad ‚Ä¢ BONUSAKTION!</div>
                    <div>
                        <strong>Zeitaufwand:</strong> 1 BONUSAKTION<br>
                        <strong>Reichweite:</strong> 18 Meter<br>
                        <strong>Komponenten:</strong> V<br>
                        <strong>Heilung:</strong> 1W4 + 3 (Zaubermodifikator)<br>
                        <strong>Besonders:</strong> Kann im selben Zug noch eine Aktion ausf√ºhren! Perfekt f√ºr Kampfheilung.
                    </div>
                </div>
            </div>
        </div>

        <!-- Custom Dialog Modal -->
        <!-- Create Character Modal -->
    <div id="createCharacterModal" class="dialog-modal">
        <div class="dialog-content" style="max-width: 600px;">
            <div class="dialog-header">
                <h2>‚ûï Neuen Charakter erstellen</h2>
                <button class="dialog-close" onclick="closeCreateCharacterModal()">√ó</button>
            </div>
            <div class="dialog-message" style="text-align: left;">
                <div style="margin-bottom: 15px;">
                    <label style="display: block; color: #ffcccc; margin-bottom: 5px; font-weight: 500;">Name:</label>
                    <input type="text" id="newCharName" placeholder="Name des Charakters" style="width: 100%; padding: 10px; background: rgba(0,0,0,0.5); border: 2px solid rgba(255,215,0,0.6); border-radius: 8px; color: #fff; font-size: 1em;">
                </div>
                <div style="margin-bottom: 15px;">
                    <label style="display: block; color: #ffcccc; margin-bottom: 5px; font-weight: 500;">Klasse:</label>
                    <select id="newCharClass" style="width: 100%; padding: 10px; background: rgba(0,0,0,0.5); border: 2px solid rgba(255,215,0,0.6); border-radius: 8px; color: #fff; font-size: 1em;">
                        <option value="Barde">Barde</option>
                        <option value="Barbar">Barbar</option>
                        <option value="Kleriker">Kleriker</option>
                        <option value="Druide">Druide</option>
                        <option value="K√§mpfer">K√§mpfer</option>
                        <option value="M√∂nch">M√∂nch</option>
                        <option value="Paladin">Paladin</option>
                        <option value="Waldl√§ufer">Waldl√§ufer</option>
                        <option value="Schurke">Schurke</option>
                        <option value="Zauberer">Zauberer</option>
                        <option value="Hexenmeister">Hexenmeister</option>
                        <option value="Zauberwirker">Zauberwirker</option>
                    </select>
                </div>
                <div style="margin-bottom: 15px;">
                    <label style="display: block; color: #ffcccc; margin-bottom: 5px; font-weight: 500;">Volk:</label>
                    <input type="text" id="newCharRace" placeholder="z.B. Tiefling (Chthonisch)" style="width: 100%; padding: 10px; background: rgba(0,0,0,0.5); border: 2px solid rgba(255,215,0,0.6); border-radius: 8px; color: #fff; font-size: 1em;">
                </div>
                <div style="margin-bottom: 15px;">
                    <label style="display: block; color: #ffcccc; margin-bottom: 5px; font-weight: 500;">Hintergrund:</label>
                    <input type="text" id="newCharBackground" placeholder="z.B. Entertainer" style="width: 100%; padding: 10px; background: rgba(0,0,0,0.5); border: 2px solid rgba(255,215,0,0.6); border-radius: 8px; color: #fff; font-size: 1em;">
                </div>
                <div style="margin-bottom: 15px;">
                    <label style="display: block; color: #ffcccc; margin-bottom: 5px; font-weight: 500;">Gesinnung:</label>
                    <select id="newCharAlignment" style="width: 100%; padding: 10px; background: rgba(0,0,0,0.5); border: 2px solid rgba(255,215,0,0.6); border-radius: 8px; color: #fff; font-size: 1em;">
                        <option value="LG">LG - Lawful Good</option>
                        <option value="NG">NG - Neutral Good</option>
                        <option value="CG">CG - Chaotic Good</option>
                        <option value="LN">LN - Lawful Neutral</option>
                        <option value="N">N - True Neutral</option>
                        <option value="CN" selected>CN - Chaotic Neutral</option>
                        <option value="LE">LE - Lawful Evil</option>
                        <option value="NE">NE - Neutral Evil</option>
                        <option value="CE">CE - Chaotic Evil</option>
                    </select>
                </div>
                <div style="margin-bottom: 15px;">
                    <label style="display: block; color: #ffcccc; margin-bottom: 5px; font-weight: 500;">Level:</label>
                    <input type="number" id="newCharLevel" value="1" min="1" max="20" style="width: 100%; padding: 10px; background: rgba(0,0,0,0.5); border: 2px solid rgba(255,215,0,0.6); border-radius: 8px; color: #fff; font-size: 1em;">
                </div>
            </div>
            <div class="dialog-buttons">
                <button class="dialog-btn dialog-btn-primary" onclick="createCharacter()">Erstellen</button>
                <button class="dialog-btn" onclick="closeCreateCharacterModal()">Abbrechen</button>
            </div>
        </div>
    </div>

    <div id="dialogModal" class="dialog-modal">
            <div class="dialog-content">
                <div class="dialog-header" id="dialogHeader">Information</div>
                <div class="dialog-message" id="dialogMessage"></div>
                <div id="dialogInputContainer" style="display: none;">
                    <input type="text" class="dialog-input" id="dialogInput" placeholder="Eingabe...">
                </div>
                <div class="dialog-buttons" id="dialogButtons"></div>
            </div>
        </div>

        <!-- Modal f√ºr neue Ausr√ºstung -->
        <div id="equipmentModal" class="modal">
            <div class="modal-content">
                <div class="modal-header">
                    <h2>‚öîÔ∏è Neue Ausr√ºstung hinzuf√ºgen</h2>
                    <button class="close-modal" onclick="closeEquipmentModal()">&times;</button>
                </div>
                <form id="equipmentForm" onsubmit="addEquipmentFromForm(event)">
                    <div class="form-group">
                        <label>Name:</label>
                        <input type="text" id="modalItemName" required placeholder="z.B. Rapier, Lederr√ºstung">
                    </div>
                    <div class="form-group">
                        <label>Typ:</label>
                        <select id="modalItemType" required onchange="updateEquipmentForm()">
                            <option value="weapon">Waffe</option>
                            <option value="armor">R√ºstung</option>
                        </select>
                    </div>
                    
                    <!-- Waffen-spezifische Felder -->
                    <div id="weaponFields" style="display: none;">
                        <div class="form-row">
                            <div class="form-group">
                                <label>Schaden:</label>
                                <input type="text" id="modalWeaponDamage" placeholder="z.B. 1d8+2">
                            </div>
                            <div class="form-group">
                                <label>Angriffsbonus:</label>
                                <input type="text" id="modalWeaponToHit" placeholder="z.B. +4">
                            </div>
                        </div>
                        <div class="form-group">
                            <label>Reichweite:</label>
                            <input type="text" id="modalWeaponRange" placeholder="z.B. 1,5m / 6-18m">
                        </div>
                        <div class="form-row">
                            <div class="form-group">
                                <label>Kampfart:</label>
                                <select id="modalWeaponCombatType">
                                    <option value="melee">Nahkampf</option>
                                    <option value="ranged">Fernkampf</option>
                                </select>
                            </div>
                            <div class="form-group">
                                <label>H√§nde:</label>
                                <select id="modalWeaponHands">
                                    <option value="1h">1 Hand (1h)</option>
                                    <option value="2h">2 H√§nde (2h)</option>
                                </select>
                            </div>
                        </div>
                        <div class="form-group">
                            <label>Slot:</label>
                            <select id="modalWeaponSlot">
                                <option value="onehanded">Einh√§ndig</option>
                                <option value="twohanded">Zweih√§ndig</option>
                            </select>
                        </div>
                        <div class="form-checkbox">
                            <input type="checkbox" id="modalWeaponLight">
                            <label for="modalWeaponLight">Leicht (kann in beiden H√§nden ausger√ºstet werden)</label>
                        </div>
                        <div class="form-group" id="offhandDamageGroup" style="display: none;">
                            <label>Nebenhand-Schaden:</label>
                            <input type="text" id="modalWeaponOffhandDamage" placeholder="z.B. 1d4">
                        </div>
                    </div>
                    
                    <!-- R√ºstungs-spezifische Felder -->
                    <div id="armorFields" style="display: none;">
                        <div class="form-row">
                            <div class="form-group">
                                <label>R√ºstungsklasse (AC):</label>
                                <input type="number" id="modalArmorAC" placeholder="z.B. 11">
                            </div>
                            <div class="form-group">
                                <label>Max. DEX-Bonus:</label>
                                <input type="number" id="modalArmorMaxDex" placeholder="z.B. 5">
                            </div>
                        </div>
                        <div class="form-checkbox">
                            <input type="checkbox" id="modalArmorDexBonus" checked>
                            <label for="modalArmorDexBonus">DEX-Bonus erlaubt</label>
                        </div>
                    </div>
                    
                    <div class="form-group" style="margin-top: 20px; display: flex; gap: 10px;">
                        <button type="submit" class="btn-add" style="flex: 1;">Hinzuf√ºgen</button>
                        <button type="button" class="btn-small" onclick="closeEquipmentModal()" style="flex: 1; background: #666;">Abbrechen</button>
                    </div>
                </form>
            </div>
        </div>

        <!-- Page 4: Inventory -->
        <div id="inventory" class="page">
            <!-- Ausr√ºstungs-Slots -->
            <div class="card">
                <h2>‚öîÔ∏è Ausr√ºstung anlegen</h2>
                <div class="grid-3">
                    <div class="equipment-slot">
                        <div class="slot-label">üõ°Ô∏è R√ºstung</div>
                        <div class="slot-container" id="armorSlot" data-slot="armor" ondrop="dropItem(event)" ondragover="allowDrop(event)">
                            <div class="slot-placeholder" id="armorSlotItem">Keine R√ºstung</div>
                        </div>
                        <select id="armorSlotSelect" class="slot-select" style="display: none; margin-top: 8px; width: 100%; padding: 8px; background: rgba(0,0,0,0.5); border: 2px solid rgba(255,215,0,0.6); border-radius: 8px; color: #ffd700; font-size: 0.9em; cursor: pointer;" onchange="equipItemFromSelect('armorSlot', this.value)">
                            <option value="">-- Keine R√ºstung --</option>
                        </select>
                        <div class="slot-ac" id="armorACInfo">AC: -</div>
                    </div>
                    <div class="equipment-slot">
                        <div class="slot-label">‚öîÔ∏è Rechte Hand</div>
                        <div class="slot-container" id="mainHandSlot" data-slot="mainhand" ondrop="dropItem(event)" ondragover="allowDrop(event)">
                            <div class="slot-placeholder" id="mainHandSlotItem">Leer</div>
                        </div>
                        <select id="mainHandSlotSelect" class="slot-select" style="display: none; margin-top: 8px; width: 100%; padding: 8px; background: rgba(0,0,0,0.5); border: 2px solid rgba(255,215,0,0.6); border-radius: 8px; color: #ffd700; font-size: 0.9em; cursor: pointer;" onchange="equipItemFromSelect('mainHandSlot', this.value)">
                            <option value="">-- Keine Waffe --</option>
                        </select>
                    </div>
                    <div class="equipment-slot">
                        <div class="slot-label">‚öîÔ∏è Linke Hand</div>
                        <div class="slot-container" id="offHandSlot" data-slot="offhand" ondrop="dropItem(event)" ondragover="allowDrop(event)">
                            <div class="slot-placeholder" id="offHandSlotItem">Leer</div>
                        </div>
                        <select id="offHandSlotSelect" class="slot-select" style="display: none; margin-top: 8px; width: 100%; padding: 8px; background: rgba(0,0,0,0.5); border: 2px solid rgba(255,215,0,0.6); border-radius: 8px; color: #ffd700; font-size: 0.9em; cursor: pointer;" onchange="equipItemFromSelect('offHandSlot', this.value)">
                            <option value="">-- Keine Waffe --</option>
                        </select>
                    </div>
                </div>
            </div>

            <div class="grid-2">
                <div class="card">
                    <h2>üí∞ Verm√∂gen</h2>
                    <div class="resource-tracker">
                        <span class="resource-label">Goldm√ºnzen:</span>
                        <div class="resource-controls">
                            <button class="btn-small" onclick="adjustGold('gp', -1)">-</button>
                            <span class="editable" id="gpTracker">42</span>
                            <button class="btn-small" onclick="adjustGold('gp', 1)">+</button>
                        </div>
                    </div>
                    <div class="resource-tracker">
                        <span class="resource-label">Silberm√ºnzen:</span>
                        <div class="resource-controls">
                            <button class="btn-small" onclick="adjustGold('sp', -1)">-</button>
                            <span class="editable" id="spTracker">4</span>
                            <button class="btn-small" onclick="adjustGold('sp', 1)">+</button>
                        </div>
                    </div>
                    <div class="resource-tracker">
                        <span class="resource-label">Kupferm√ºnzen:</span>
                        <div class="resource-controls">
                            <button class="btn-small" onclick="adjustGold('cp', -1)">-</button>
                            <span class="editable" id="cpTracker">55</span>
                            <button class="btn-small" onclick="adjustGold('cp', 1)">+</button>
                        </div>
                    </div>
                    <div class="treasure-box">
                        <h3>üíé Wertgegenst√§nde</h3>
                        <div id="treasureList">
                            <div class="treasure-item" data-item='{"name":"3x Edelsteine","value":"je 10 GM","type":"treasure"}' draggable="false">
                            <span>3x Edelsteine</span>
                            <span class="treasure-value">je 10 GM</span>
                                <button class="btn-remove" onclick="removeTreasureItem(this)">√ó</button>
                        </div>
                            <div class="treasure-item" data-item='{"name":"Silberschere","value":"30 GM","type":"treasure"}' draggable="false">
                            <span>Silberschere</span>
                            <span class="treasure-value">30 GM</span>
                                <button class="btn-remove" onclick="removeTreasureItem(this)">√ó</button>
                        </div>
                            <div class="treasure-item" data-item='{"name":"Silberner Handspiegel","value":"50 GM","type":"treasure"}' draggable="false">
                            <span>Silberner Handspiegel</span>
                            <span class="treasure-value">50 GM</span>
                                <button class="btn-remove" onclick="removeTreasureItem(this)">√ó</button>
                        </div>
                            <div class="treasure-item" data-item='{"name":"Silberkamm","value":"25 GM","type":"treasure"}' draggable="false">
                            <span>Silberkamm</span>
                            <span class="treasure-value">25 GM</span>
                                <button class="btn-remove" onclick="removeTreasureItem(this)">√ó</button>
                            </div>
                        </div>
                        <div class="add-item-container" style="margin-top: 10px;">
                            <input type="text" class="add-item-input" id="newTreasureName" placeholder="Name...">
                            <input type="text" class="add-item-input" id="newTreasureValue" placeholder="Wert..." style="max-width: 100px;">
                            <button class="btn-add" onclick="addTreasureItem()">+</button>
                        </div>
                    </div>
                </div>

                <div class="card">
                    <h2>üéµ Musikinstrumente</h2>
                    <div id="instrumentList">
                        <div class="inventory-item">
                            <span>üé∏ Laute (E-Gitarre Style)</span>
                        </div>
                        <div class="inventory-item">
                            <span>üé∂ Fl√∂te</span>
                        </div>
                        <div class="inventory-item">
                            <span>üéº Lyra</span>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Kategorisiertes Inventar -->
            <div class="card">
                <h2>üéí Ausr√ºstung</h2>
                <div class="inventory-category">
                    <h3>‚öîÔ∏è Waffen & R√ºstung</h3>
                    <div id="equipmentList">
                        <div class="inventory-item" draggable="true" ondragstart="dragItem(event)" data-item='{"name":"Lederr√ºstung","type":"armor","ac":"11","dexBonus":true,"maxDexBonus":5,"id":"leather1"}' data-item-id="leather1">
                            <span>üõ°Ô∏è Lederr√ºstung</span>
                        <div class="item-controls">
                                <button class="btn-remove" onclick="removeInventoryItem(this, 'equipment')">√ó</button>
                        </div>
                    </div>
                        <div class="inventory-item" draggable="true" ondragstart="dragItem(event)" data-item='{"name":"Rapier","type":"weapon","slot":"onehanded","hands":"1h","combatType":"melee","damage":"1d8+2","toHit":"+4","range":"1,5m","id":"rapier1","light":false}' data-item-id="rapier1">
                            <span>‚öîÔ∏è Rapier</span>
                            <div class="item-controls">
                                <button class="btn-remove" onclick="removeInventoryItem(this, 'equipment')">√ó</button>
                            </div>
                        </div>
                        <div class="inventory-item" draggable="true" ondragstart="dragItem(event)" data-item='{"name":"Dolch","type":"weapon","slot":"onehanded","hands":"1h","combatType":"melee","damage":"1d4+2","toHit":"+4","range":"1,5m / 6-18m (geworfen: 6-18m / 18-54m)","id":"dagger1","light":true,"offhandDamage":"1d4"}' data-item-id="dagger1">
                            <span>‚öîÔ∏è Dolch</span>
                            <div class="item-controls">
                                <button class="btn-remove" onclick="removeInventoryItem(this, 'equipment')">√ó</button>
                            </div>
                        </div>
                        <div class="inventory-item" draggable="true" ondragstart="dragItem(event)" data-item='{"name":"Dolch","type":"weapon","slot":"onehanded","hands":"1h","combatType":"melee","damage":"1d4+2","toHit":"+4","range":"1,5m / 6-18m (geworfen: 6-18m / 18-54m)","id":"dagger2","light":true,"offhandDamage":"1d4"}' data-item-id="dagger2">
                            <span>‚öîÔ∏è Dolch</span>
                            <div class="item-controls">
                                <button class="btn-remove" onclick="removeInventoryItem(this, 'equipment')">√ó</button>
                            </div>
                        </div>
                        <div class="inventory-item" draggable="true" ondragstart="dragItem(event)" data-item='{"name":"Dolch","type":"weapon","slot":"onehanded","hands":"1h","combatType":"melee","damage":"1d4+2","toHit":"+4","range":"1,5m / 6-18m (geworfen: 6-18m / 18-54m)","id":"dagger3","light":true,"offhandDamage":"1d4"}' data-item-id="dagger3">
                            <span>‚öîÔ∏è Dolch</span>
                            <div class="item-controls">
                                <button class="btn-remove" onclick="removeInventoryItem(this, 'equipment')">√ó</button>
                            </div>
                        </div>
                    </div>
                    <div class="add-item-container" style="flex-direction: column; gap: 10px;">
                        <button class="btn-add" onclick="showAddEquipmentModal()" style="width: 100%;">+ Neue Ausr√ºstung hinzuf√ºgen</button>
                    </div>
                </div>

                <div class="inventory-category" style="margin-top: 20px;">
                    <h3>üß™ Verbrauchsgegenst√§nde</h3>
                    <div id="consumablesList">
                        <div class="inventory-item" data-item='{"name":"Aloe Vera Pflanze","type":"consumable"}' data-item-id="aloe1">
                            <span>üå± Aloe Vera Pflanze</span>
                            <div class="item-controls">
                                <button class="btn-remove" onclick="removeInventoryItem(this, 'consumables')">√ó</button>
                            </div>
                        </div>
                    </div>
                    <div class="add-item-container">
                        <input type="text" class="add-item-input" id="newConsumableInput" placeholder="Neuer Verbrauchsgegenstand...">
                        <button class="btn-add" onclick="addInventoryItem('consumables')">+ Hinzuf√ºgen</button>
                    </div>
                </div>

                <div class="inventory-category" style="margin-top: 20px;">
                    <h3>üì¶ Gebrauchsgegenst√§nde</h3>
                    <div id="toolsList">
                        <div class="inventory-item" data-item='{"name":"Entertainer-Paket","type":"tool"}' onclick="removeInventoryItem(this, 'tools')">
                        <span>Entertainer-Paket (Rucksack, Schlafsack, 2 Kost√ºme, 5 Kerzen, 5 Rationen, Wasserschlauch, Verkleidungsset)</span>
                        <div class="item-controls">
                                <button class="btn-remove" onclick="removeInventoryItem(this, 'tools')">√ó</button>
                        </div>
                    </div>
                        <div class="inventory-item" data-item='{"name":"G√ºrteltasche","type":"tool"}' onclick="removeInventoryItem(this, 'tools')">
                        <span>G√ºrteltasche</span>
                        <div class="item-controls">
                                <button class="btn-remove" onclick="removeInventoryItem(this, 'tools')">√ó</button>
                        </div>
                    </div>
                        <div class="inventory-item" data-item='{"name":"Gew√∂hnliche Kleidung","type":"tool"}' onclick="removeInventoryItem(this, 'tools')">
                        <span>Gew√∂hnliche Kleidung</span>
                        <div class="item-controls">
                                <button class="btn-remove" onclick="removeInventoryItem(this, 'tools')">√ó</button>
                        </div>
                    </div>
                        <div class="inventory-item" data-item='{"name":"2x weitere Kost√ºme","type":"tool"}' onclick="removeInventoryItem(this, 'tools')">
                        <span>2x weitere Kost√ºme</span>
                        <div class="item-controls">
                                <button class="btn-remove" onclick="removeInventoryItem(this, 'tools')">√ó</button>
                        </div>
                    </div>
                        <div class="inventory-item" data-item='{"name":"Parf√ºm","type":"tool"}' onclick="removeInventoryItem(this, 'tools')">
                        <span>Parf√ºm</span>
                        <div class="item-controls">
                                <button class="btn-remove" onclick="removeInventoryItem(this, 'tools')">√ó</button>
                        </div>
                    </div>
                        <div class="inventory-item" data-item='{"name":"Spiegel","type":"tool"}' onclick="removeInventoryItem(this, 'tools')">
                        <span>Spiegel</span>
                        <div class="item-controls">
                                <button class="btn-remove" onclick="removeInventoryItem(this, 'tools')">√ó</button>
                        </div>
                    </div>
                </div>
                <div class="add-item-container">
                        <input type="text" class="add-item-input" id="newToolInput" placeholder="Neuer Gebrauchsgegenstand...">
                        <button class="btn-add" onclick="addInventoryItem('tools')">+ Hinzuf√ºgen</button>
                </div>
                </div>

                <div style="margin-top: 15px; padding: 10px; background: rgba(255,215,0,0.1); border-radius: 5px;">
                    <strong>Traglast:</strong> ~38 kg von 54 kg Maximum
                </div>
            </div>
        </div>

        <!-- Page 5: Playing the Game / Rules -->
        <div id="rules" class="page">
            <div class="card">
                <h2>üé≤ Grundlegende Spielmechaniken</h2>
                <div class="rule-box">
                    <h4>W√ºrfelw√ºrfe</h4>
                    <ul>
                        <li><strong>Attributswurf:</strong> W20 + Attributsmodifikator (+ Ge√ºbtheitsbonus wenn ge√ºbt)</li>
                        <li><strong>Rettungswurf:</strong> W20 + Attributsmodifikator (+ Ge√ºbtheitsbonus wenn ge√ºbt)</li>
                        <li><strong>Angriffswurf:</strong> W20 + Angriffsbonus vs. R√ºstungsklasse</li>
                        <li><strong>Vorteil:</strong> Wirf 2W20, nimm das h√∂here Ergebnis</li>
                        <li><strong>Nachteil:</strong> Wirf 2W20, nimm das niedrigere Ergebnis</li>
                        <li><strong>Kritischer Treffer (nat. 20):</strong> Verdoppele alle Schadensw√ºrfel</li>
                        <li><strong>Kritischer Fehlschlag (nat. 1):</strong> Automatischer Fehlschlag bei Angriffen</li>
                    </ul>
                </div>
                <div class="rule-box">
                    <h4>Initiative & Kampfrunden</h4>
                    <ul>
                        <li><strong>Initiative:</strong> W20 + GES-Modifikator (h√∂her agiert zuerst)</li>
                        <li><strong>Eine Runde:</strong> 6 Sekunden Spielzeit</li>
                        <li><strong>Dein Zug besteht aus:</strong> Bewegung + Aktion + m√∂gliche Bonusaktion</li>
                        <li><strong>Reaktion:</strong> 1x zwischen deinen Z√ºgen (z.B. Gelegenheitsangriff)</li>
                    </ul>
                </div>
            </div>

            <div class="grid-3">
                <div class="card">
                    <h2>‚öîÔ∏è Aktionen im Kampf</h2>
                    <div class="rule-box">
                        <h4>Standard-Aktionen</h4>
                        <ul>
                            <li><strong>Angreifen:</strong> Nahkampf oder Fernkampf</li>
                            <li><strong>Sprint:</strong> Verdoppele deine Bewegung</li>
                            <li><strong>Ausweichen:</strong> Angriffe gegen dich haben Nachteil</li>
                            <li><strong>R√ºckzug:</strong> Keine Gelegenheitsangriffe provozieren</li>
                            <li><strong>Verstecken:</strong> Heimlichkeitswurf</li>
                            <li><strong>Helfen:</strong> Gib einem Verb√ºndeten Vorteil</li>
                            <li><strong>Zauber wirken:</strong> Mit Zeitaufwand "1 Aktion"</li>
                            <li><strong>Bereithalten:</strong> Aktion als Reaktion vorbereiten</li>
                            <li><strong>Suchen:</strong> Wahrnehmungswurf</li>
                            <li><strong>Verwenden:</strong> Gegenstand benutzen</li>
                        </ul>
                    </div>
                </div>

                <div class="card">
                    <h2>üèÉ Bewegung</h2>
                    <div class="rule-box">
                        <h4>Bewegungsarten</h4>
                        <ul>
                            <li><strong>Normal:</strong> 9 Meter pro Zug</li>
                            <li><strong>Schwieriges Gel√§nde:</strong> 1m kostet 2m Bewegung</li>
                            <li><strong>Kriechen:</strong> 1m kostet 2m Bewegung</li>
                            <li><strong>Klettern/Schwimmen:</strong> 1m kostet 2m (ohne Kletter-/Schwimmtempo)</li>
                            <li><strong>Aufstehen:</strong> Halbe Bewegung</li>
                            <li><strong>Springen:</strong> STR-Wert in Fu√ü mit Anlauf</li>
                            <li><strong>Fallen lassen:</strong> Keine Bewegungskosten</li>
                        </ul>
                        <h4>Spezialregeln</h4>
                        <ul>
                            <li><strong>Gelegenheitsangriff:</strong> Wenn Feind deine Reichweite verl√§sst</li>
                            <li><strong>Bewegung aufteilen:</strong> Vor und nach Aktionen m√∂glich</li>
                        </ul>
                    </div>
                </div>

                <div class="card">
                    <h2>‚ú® Bonusaktionen</h2>
                    <div class="rule-box">
                        <h4>Deine Bonusaktionen</h4>
                        <ul>
                            <li><strong>Bardische Inspiration:</strong> W6 an Verb√ºndeten vergeben</li>
                            <li><strong>Heilendes Wort:</strong> Zauber als Bonusaktion</li>
                            <li><strong>Zweihandkampf:</strong> Angriff mit Nebenhand</li>
                            <li><strong>Bestimmte Zauber:</strong> Mit Zeitaufwand "Bonusaktion"</li>
                        </ul>
                        <h4>Wichtig</h4>
                        <p style="margin-top: 10px;">Nur EINE Bonusaktion pro Zug! Kannst du nicht gegen andere Bonusaktion tauschen.</p>
                    </div>
                </div>
            </div>

            <div class="card">
                <h2>üõ°Ô∏è Zust√§nde & Effekte</h2>
                <div class="grid-3">
                    <div class="rule-box">
                        <h4>H√§ufige Zust√§nde</h4>
                        <ul>
                            <li><strong>Blind:</strong> Auto-Fehlschlag bei Sicht, Nachteil auf Angriffe</li>
                            <li><strong>Bezaubert:</strong> Kann Bezauberer nicht angreifen</li>
                            <li><strong>Taub:</strong> Auto-Fehlschlag bei Geh√∂r-Wahrnehmung</li>
                            <li><strong>Ersch√∂pfung:</strong> Stufen 1-6, kumulative Mali</li>
                            <li><strong>Ver√§ngstigt:</strong> Nachteil solange Quelle in Sicht</li>
                            <li><strong>Gegriffen:</strong> Bewegung 0, Flucht mit Aktion</li>
                            <li><strong>Liegend:</strong> Nachteil auf Angriffe, Nahkampf gegen dich Vorteil</li>
                        </ul>
                    </div>
                    <div class="rule-box">
                        <h4>Schwere Zust√§nde</h4>
                        <ul>
                            <li><strong>Kampfunf√§hig:</strong> Keine Aktionen/Reaktionen</li>
                            <li><strong>Paralysiert:</strong> Kampfunf√§hig, Auto-Fehlschlag STR/GES</li>
                            <li><strong>Versteinert:</strong> Wie paralysiert + Schadensresistenz</li>
                            <li><strong>Vergiftet:</strong> Nachteil auf Angriffe und Attributsw√ºrfe</li>
                            <li><strong>Festgesetzt:</strong> Bewegung 0, nicht √§nderbar</li>
                            <li><strong>Bet√§ubt:</strong> Kampfunf√§hig, Auto-Fehlschlag, Angriffe haben Vorteil</li>
                            <li><strong>Bewusstlos:</strong> Kampfunf√§hig, liegend, l√§sst alles fallen</li>
                        </ul>
                    </div>
                    <div class="rule-box">
                        <h4>Todesrettungsw√ºrfe</h4>
                        <ul>
                            <li><strong>Bei 0 TP:</strong> Bewusstlos und sterbend</li>
                            <li><strong>Jede Runde:</strong> W20, 10+ = Erfolg, 9- = Misserfolg</li>
                            <li><strong>3 Erfolge:</strong> Stabilisiert bei 1 TP</li>
                            <li><strong>3 Misserfolge:</strong> Tod</li>
                            <li><strong>Nat. 20:</strong> Sofort 1 TP und bei Bewusstsein</li>
                            <li><strong>Nat. 1:</strong> Z√§hlt als 2 Misserfolge</li>
                            <li><strong>Schaden bei 0 TP:</strong> Auto-Misserfolg (Krit = 2)</li>
                        </ul>
                    </div>
                </div>
            </div>

            <div class="card">
                <h2>üìú Zaubern & Konzentration</h2>
                <div class="grid-2">
                    <div class="rule-box">
                        <h4>Zauberregeln</h4>
                        <ul>
                            <li><strong>Zauberpl√§tze:</strong> Verbraucht beim Wirken, kehren nach langer Rast zur√ºck</li>
                            <li><strong>Zaubertricks:</strong> Beliebig oft, kein Platz n√∂tig</li>
                            <li><strong>Komponenten:</strong> V=Verbal, S=Somatisch, M=Material</li>
                            <li><strong>Ritual:</strong> +10 Minuten, kein Platz verbraucht (wenn m√∂glich)</li>
                            <li><strong>H√∂here Grade:</strong> Mehr Platz = st√§rkerer Effekt</li>
                        </ul>
                    </div>
                    <div class="rule-box">
                        <h4>Konzentration</h4>
                        <ul>
                            <li><strong>Nur 1 Zauber:</strong> Neuer Konz-Zauber beendet alten</li>
                            <li><strong>Konz-Rettung bei Schaden:</strong> KON-Rettung SG 10 oder halber Schaden (h√∂heres)</li>
                            <li><strong>Beendet durch:</strong> Anderen Konz-Zauber, Kampfunf√§hig, Tod</li>
                            <li><strong>Freiwillig beenden:</strong> Keine Aktion n√∂tig</li>
                        </ul>
                    </div>
                </div>
            </div>
        </div>

        <!-- Page 6: Notes -->
        <div id="notes" class="page">
            <div class="card">
                <h2>üìù Abenteuer-Notizen</h2>
                <textarea class="notes-area" id="adventureNotes" placeholder="Session-Notizen, NPCs, Quests, wichtige Ereignisse..."></textarea>
            </div>

            <div class="card">
                <h2>üé≠ Charakterentwicklung & Ideen</h2>
                <textarea class="notes-area" id="characterNotes" placeholder="Backstory-Details, Charakterziele, Beziehungen, Entwicklungsideen..."></textarea>
            </div>

            <div class="card">
                <h2>üéµ Bar-itons Auftritte & Lieder</h2>
                <div style="margin-bottom: 15px;">
                    <label style="display: block; margin-bottom: 8px; color: #ffb3b3; font-weight: bold;">üéµ Bar-itons Lieder:</label>
                    <div id="baritonSongsList" style="margin-bottom: 10px;">
                        <!-- Lieder werden hier dynamisch geladen -->
                    </div>
                    <div style="display: flex; align-items: center; gap: 10px; background: rgba(0, 0, 0, 0.3); padding: 10px; border-radius: 5px; border: 1px solid #444;">
                        <audio id="performanceAudio" controls style="flex: 1; max-width: 100%;">
                            <source id="audioSource" src="" type="audio/mpeg">
                            Dein Browser unterst√ºtzt das Audio-Element nicht.
                        </audio>
                        <input type="file" id="audioFileInput" accept="audio/mpeg,audio/mp3" style="display: none;" onchange="loadAudioFile(event)">
                        <button onclick="document.getElementById('audioFileInput').click()" class="btn-small" style="white-space: nowrap;">üìÅ Noch ein Lied hinzuf√ºgen</button>
                    </div>
                    <div id="audioFileName" style="margin-top: 5px; color: #aaa; font-size: 0.9em;"></div>
                </div>
                <textarea class="notes-area" id="performanceNotes" placeholder="Gespielte Lieder, Publikumsreaktionen, Tavernen-Auftritte, neue Song-Ideen..."></textarea>
            </div>
        </div>
    </div>

    <script>
        // Character portrait toggle
        let isStageMode = false;
        let portraits = {
            civil: '/images/Bariton_ziv.png',
            stage: '/images/Bariton.png'
        };
        
        // Mache portraits global verf√ºgbar
        window.portraits = portraits;
        window.isStageMode = isStageMode;
        
        // Setze initiales Bild
        function loadPortraits() {
            const img = document.getElementById('characterImage');
            if (img) {
                img.src = isStageMode ? portraits.stage : portraits.civil;
            }
        }
        
        // Lade Portraits beim Start
        loadPortraits();

        function togglePortrait() {
            isStageMode = !isStageMode;
            window.isStageMode = isStageMode;
            document.getElementById('characterImage').src = isStageMode ? portraits.stage : portraits.civil;
            saveCharacterData();
        }
        
        // Audio-Player Funktionen f√ºr Performance-Bereich
        function loadAudioFile(event) {
            const file = event.target.files[0];
            if (!file) return;
            
            // Pr√ºfe ob es eine MP3-Datei ist
            if (!file.type.includes('audio/mpeg') && !file.name.toLowerCase().endsWith('.mp3')) {
                if (typeof customAlert === 'function') {
                    customAlert('Bitte w√§hle eine MP3-Datei aus.');
                } else {
                    alert('Bitte w√§hle eine MP3-Datei aus.');
                }
                return;
            }
            
            // Erstelle Object URL f√ºr lokale Datei
            const audioPlayer = document.getElementById('performanceAudio');
            const audioSource = document.getElementById('audioSource');
            const fileNameDisplay = document.getElementById('audioFileName');
            
            if (audioPlayer && audioSource) {
                // Entferne alte URL falls vorhanden
                if (audioSource.src && audioSource.src.startsWith('blob:')) {
                    URL.revokeObjectURL(audioSource.src);
                }
                
                // Erstelle neue URL f√ºr die Datei
                const objectUrl = URL.createObjectURL(file);
                audioSource.src = objectUrl;
                audioPlayer.load();
                
                // Zeige Dateinamen an
                if (fileNameDisplay) {
                    fileNameDisplay.textContent = `üìÄ Aktuelles Lied: ${file.name}`;
                }
                
                // Speichere Dateinamen in localStorage (f√ºr Persistenz)
                localStorage.setItem('performanceAudioFile', file.name);
                
                console.log('Audio-Datei geladen:', file.name);
            }
        }
        
        // Bar-iton's Lieder Liste - Lieder die nur ihm geh√∂ren
        // Bar-iton's Lieder Liste (wird dynamisch geladen)
        let baritonSongs = [];
        
        // Lade Bar-iton's Lieder Liste vom Server
        async function loadBaritonSongs() {
            const songsList = document.getElementById('baritonSongsList');
            if (!songsList) return;
            
            // Zeige Ladeanzeige
            songsList.innerHTML = '<p style="color: #aaa; font-style: italic;">Lade Lieder...</p>';
            
            try {
                // Lade Songs vom Server
                const response = await fetch('/backend/api/audio.php');
                
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }
                
                const data = await response.json();
                
                if (!data.success || !data.songs) {
                    throw new Error(data.error || 'Unbekannter Fehler beim Laden der Lieder');
                }
                
                // Speichere Songs global
                baritonSongs = data.songs;
                
                // Leere Liste
                songsList.innerHTML = '';
                
                if (baritonSongs.length === 0) {
                    songsList.innerHTML = '<p style="color: #aaa; font-style: italic;">Keine Lieder vorhanden. Bitte MP3-Dateien ins frontend/audio Verzeichnis kopieren.</p>';
                    return;
                }
                
                // Zeige Songs an
                baritonSongs.forEach((song, index) => {
                    const songItem = document.createElement('div');
                    songItem.style.cssText = 'display: flex; align-items: center; justify-content: space-between; padding: 8px 12px; margin-bottom: 5px; background: rgba(255, 179, 179, 0.1); border-radius: 5px; border: 1px solid rgba(255, 179, 179, 0.3);';
                    
                    // Erstelle Button mit Event-Listener
                    const playButton = document.createElement('button');
                    playButton.className = 'btn-small';
                    playButton.style.cssText = 'white-space: nowrap; margin-left: 10px;';
                    playButton.textContent = '‚ñ∂Ô∏è Abspielen';
                    playButton.onclick = function() {
                        // song.path ist bereits korrekt URL-encoded vom Server
                        console.log('üéµ Button geklickt f√ºr:', song.title);
                        console.log('  Verwendeter Pfad:', song.path);
                        playBaritonSong(song.path, song.title);
                    };
                    
                    const songNameDiv = document.createElement('div');
                    songNameDiv.style.cssText = 'flex: 1;';
                    songNameDiv.innerHTML = `<div style="color: #ffb3b3; font-weight: bold;">üéµ ${song.title}</div><div style="color: #888; font-size: 0.85em; margin-top: 2px;">${song.sizeFormatted}</div>`;
                    
                    songItem.appendChild(songNameDiv);
                    songItem.appendChild(playButton);
                    songsList.appendChild(songItem);
                });
                
                console.log(`‚úì ${baritonSongs.length} Lied(er) geladen`);
                
            } catch (error) {
                console.error('‚úó Fehler beim Laden der Lieder:', error);
                songsList.innerHTML = `<p style="color: #ff6b6b; font-style: italic;">Fehler beim Laden: ${error.message}</p>`;
            }
        }
        
        // Spiele Bar-iton's Lied ab
        function playBaritonSong(audioPath, songName) {
            console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
            console.log('üéµ START: playBaritonSong()');
            console.log('  Pfad:', audioPath);
            console.log('  Titel:', songName);
            console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
            
            const audioPlayer = document.getElementById('performanceAudio');
            const audioSource = document.getElementById('audioSource');
            const fileNameDisplay = document.getElementById('audioFileName');
            
            if (!audioPlayer || !audioSource) {
                console.error('‚ùå FEHLER: Audio-Elemente nicht gefunden!');
                console.error('  audioPlayer:', audioPlayer);
                console.error('  audioSource:', audioSource);
                return;
            }
            
            console.log('‚úì Audio-Elemente gefunden');
            console.log('  Altes audioPlayer:', audioPlayer);
            console.log('  Altes audioSource:', audioSource);
            
            // Entferne alte Event-Listener (falls vorhanden)
            const newAudioPlayer = audioPlayer.cloneNode(true);
            audioPlayer.parentNode.replaceChild(newAudioPlayer, audioPlayer);
            const newAudioSource = document.getElementById('audioSource');
            
            console.log('‚úì Audio-Elemente geklont und ersetzt');
            console.log('  Neues audioPlayer:', newAudioPlayer);
            console.log('  Neues audioSource:', newAudioSource);
            
            // Setze neue Quelle - dekodiere URL falls n√∂tig
            // audioPath kommt bereits URL-encoded vom Server, verwende direkt
            newAudioSource.src = audioPath;
            console.log('‚úì Audio-Quelle gesetzt:', newAudioSource.src);
            console.log('  Vollst√§ndige URL:', window.location.origin + audioPath);
            
            // Teste ob Datei erreichbar ist
            fetch(audioPath, { method: 'HEAD' })
                .then(response => {
                    console.log('‚úì Datei-Erreichbarkeit gepr√ºft:');
                    console.log('  Status:', response.status, response.statusText);
                    console.log('  Content-Type:', response.headers.get('Content-Type'));
                    console.log('  Content-Length:', response.headers.get('Content-Length'));
                    if (!response.ok) {
                        console.error('  ‚ùå Datei nicht erreichbar! Status:', response.status);
                    }
                })
                .catch(err => {
                    console.error('  ‚ùå Fehler beim Pr√ºfen der Datei-Erreichbarkeit:', err);
                });
            
            // Speichere aktuelles Lied
            const filename = audioPath.split('/').pop();
            localStorage.setItem('performanceAudioFile', filename);
            
            if (fileNameDisplay) {
                fileNameDisplay.textContent = `üìÄ Aktuelles Lied: ${songName}`;
            }
            
            // Lade Audio
            console.log('üì• Rufe audioPlayer.load() auf...');
            newAudioPlayer.load();
            console.log('‚úì audioPlayer.load() aufgerufen');
            console.log('  Initialer readyState:', newAudioPlayer.readyState);
            console.log('  Initialer networkState:', newAudioPlayer.networkState);
            
            // Wiedergabe-Funktion
            let playAttempted = false;
            
            const attemptPlay = (eventName) => {
                console.log(`\nüîÑ attemptPlay() aufgerufen von: ${eventName}`);
                console.log(`  playAttempted: ${playAttempted}`);
                console.log(`  readyState: ${newAudioPlayer.readyState}`);
                console.log(`  networkState: ${newAudioPlayer.networkState}`);
                console.log(`  duration: ${newAudioPlayer.duration}`);
                console.log(`  paused: ${newAudioPlayer.paused}`);
                console.log(`  src: ${newAudioSource.src}`);
                
                if (playAttempted) {
                    console.log(`  ‚è≠Ô∏è [${eventName}] Wiedergabe bereits versucht, √ºberspringe...`);
                    return;
                }
                
                // Pr√ºfe ob Audio bereit ist (readyState >= 2 = HAVE_CURRENT_DATA)
                const readyState = newAudioPlayer.readyState;
                console.log(`  Pr√ºfe readyState: ${readyState} (ben√∂tigt: >= 2)`);
                
                if (readyState < 2) {
                    console.log(`  ‚è≥ [${eventName}] Audio noch nicht bereit (readyState: ${readyState}), warte...`);
                    return;
                }
                
                playAttempted = true;
                console.log(`  ‚úì Audio ist bereit! Starte Wiedergabe...`);
                
                // Versuche Wiedergabe
                console.log('  üì¢ Rufe audioPlayer.play() auf...');
                const playPromise = newAudioPlayer.play();
                console.log('  playPromise:', playPromise);
                
                if (playPromise !== undefined) {
                    console.log('  ‚úì play() gibt Promise zur√ºck, warte auf Ergebnis...');
                    playPromise.then(() => {
                        console.log('  ‚úÖ ERFOLG: Wiedergabe gestartet!');
                        console.log('    paused:', newAudioPlayer.paused);
                        console.log('    currentTime:', newAudioPlayer.currentTime);
                        if (fileNameDisplay) {
                            fileNameDisplay.textContent = `‚ñ∂Ô∏è Aktuelles Lied: ${songName} (wird abgespielt)`;
                        }
                    }).catch(err => {
                        console.error('  ‚ùå FEHLER: Automatische Wiedergabe fehlgeschlagen!');
                        console.error('    Fehler-Objekt:', err);
                        console.error('    Fehler-Name:', err.name);
                        console.error('    Fehler-Message:', err.message);
                        console.error('    Fehler-Stack:', err.stack);
                        // Zeige Fehler an
                        if (fileNameDisplay) {
                            fileNameDisplay.textContent = `‚ö†Ô∏è ${err.message}. Bitte manuell auf Play klicken.`;
                        }
                        // Setze playAttempted zur√ºck f√ºr manuelles Abspielen
                        playAttempted = false;
                    });
                } else {
                    // Fallback f√ºr √§ltere Browser
                    console.log('  ‚ö†Ô∏è play() gibt kein Promise zur√ºck (√§lterer Browser?), rufe direkt auf...');
                    try {
                        newAudioPlayer.play();
                        console.log('  ‚úì Wiedergabe gestartet (ohne Promise)');
                    } catch (err) {
                        console.error('  ‚ùå FEHLER beim direkten play():', err);
                    }
                }
            };
            
            // Event-Listener f√ºr verschiedene Lade-Phasen
            console.log('üìã Registriere Event-Listener...');
            
            newAudioPlayer.addEventListener('loadstart', () => {
                console.log('üì° EVENT: loadstart');
                console.log('  readyState:', newAudioPlayer.readyState);
                console.log('  networkState:', newAudioPlayer.networkState);
            }, { once: true });
            
            newAudioPlayer.addEventListener('loadeddata', () => {
                console.log('üì° EVENT: loadeddata');
                console.log('  readyState:', newAudioPlayer.readyState);
                console.log('  duration:', newAudioPlayer.duration);
                attemptPlay('loadeddata');
            }, { once: true });
            
            newAudioPlayer.addEventListener('canplay', () => {
                console.log('üì° EVENT: canplay');
                console.log('  readyState:', newAudioPlayer.readyState);
                attemptPlay('canplay');
            }, { once: true });
            
            newAudioPlayer.addEventListener('canplaythrough', () => {
                console.log('üì° EVENT: canplaythrough');
                console.log('  readyState:', newAudioPlayer.readyState);
                attemptPlay('canplaythrough');
            }, { once: true });
            
            // Fallback: Versuche nach kurzer Verz√∂gerung abzuspielen
            console.log('‚è±Ô∏è Setze Timeout-Fallbacks...');
            setTimeout(() => {
                console.log('‚è±Ô∏è TIMEOUT: 500ms erreicht');
                if (!playAttempted) {
                    console.log('  ‚Üí Versuche Wiedergabe...');
                    attemptPlay('timeout-500ms');
                } else {
                    console.log('  ‚Üí Wiedergabe bereits versucht, √ºberspringe');
                }
            }, 500);
            
            // Zus√§tzlicher Fallback nach 2 Sekunden
            setTimeout(() => {
                console.log('‚è±Ô∏è TIMEOUT: 2s erreicht');
                if (!playAttempted) {
                    console.log('  ‚Üí Versuche Wiedergabe...');
                    attemptPlay('timeout-2s');
                } else {
                    console.log('  ‚Üí Wiedergabe bereits versucht, √ºberspringe');
                }
            }, 2000);
            
            console.log('‚úì Event-Listener und Timeouts registriert');
            console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n');
            
            // Fehlerbehandlung
            newAudioPlayer.addEventListener('error', function(e) {
                console.error('‚ùå Audio-Fehler aufgetreten!', e);
                const error = newAudioPlayer.error;
                if (error) {
                    let errorMsg = 'Unbekannter Fehler';
                    switch(error.code) {
                        case error.MEDIA_ERR_ABORTED:
                            errorMsg = 'Abgebrochen';
                            break;
                        case error.MEDIA_ERR_NETWORK:
                            errorMsg = 'Netzwerk-Fehler - Datei nicht gefunden (404)';
                            break;
                        case error.MEDIA_ERR_DECODE:
                            errorMsg = 'Datei konnte nicht decodiert werden';
                            break;
                        case error.MEDIA_ERR_SRC_NOT_SUPPORTED:
                            errorMsg = 'Datei-Format nicht unterst√ºtzt';
                            break;
                    }
                    console.error('Audio-Fehler Details:', {
                        code: error.code,
                        message: errorMsg,
                        src: newAudioSource.src,
                        networkState: newAudioPlayer.networkState,
                        readyState: newAudioPlayer.readyState
                    });
                    if (fileNameDisplay) {
                        fileNameDisplay.textContent = `‚ùå Fehler: ${errorMsg} (${newAudioSource.src}). Bitte pr√ºfen Sie die Browser-Konsole.`;
                    }
                } else {
                    console.error('Audio-Fehler ohne Error-Objekt:', {
                        src: newAudioSource.src,
                        networkState: newAudioPlayer.networkState,
                        readyState: newAudioPlayer.readyState
                    });
                    if (fileNameDisplay) {
                        fileNameDisplay.textContent = `‚ùå Fehler: Datei konnte nicht geladen werden (${newAudioSource.src}). Bitte pr√ºfen Sie die Browser-Konsole.`;
                    }
                }
            }, { once: true });
            
            // Zus√§tzliche Event-Listener f√ºr Debugging
            newAudioPlayer.addEventListener('progress', () => {
                console.log('üì° EVENT: progress');
                console.log('  readyState:', newAudioPlayer.readyState);
                console.log('  buffered ranges:', newAudioPlayer.buffered.length);
                if (newAudioPlayer.buffered.length > 0) {
                    console.log('  buffered end:', newAudioPlayer.buffered.end(0));
                }
            });
            newAudioPlayer.addEventListener('stalled', () => {
                console.warn('‚ö†Ô∏è EVENT: stalled - Laden h√§ngt');
                console.warn('  readyState:', newAudioPlayer.readyState);
                console.warn('  networkState:', newAudioPlayer.networkState);
            });
            newAudioPlayer.addEventListener('suspend', () => {
                console.warn('‚ö†Ô∏è EVENT: suspend - Laden pausiert');
            });
            newAudioPlayer.addEventListener('waiting', () => {
                console.warn('‚ö†Ô∏è EVENT: waiting - Wartet auf Daten');
            });
            newAudioPlayer.addEventListener('playing', () => {
                console.log('‚úÖ EVENT: playing - Wiedergabe l√§uft!');
                console.log('  currentTime:', newAudioPlayer.currentTime);
                console.log('  duration:', newAudioPlayer.duration);
            });
            newAudioPlayer.addEventListener('pause', () => {
                console.log('‚è∏Ô∏è EVENT: pause - Wiedergabe pausiert');
            });
            newAudioPlayer.addEventListener('ended', () => {
                console.log('üèÅ EVENT: ended - Wiedergabe beendet');
            });
        }
        
        // Lade gespeicherte Audio-Datei beim Seitenstart (falls vorhanden)
        function loadSavedAudio() {
            const savedFileName = localStorage.getItem('performanceAudioFile');
            if (savedFileName) {
                // Versuche Datei aus /audio/ Verzeichnis zu laden
                const audioSource = document.getElementById('audioSource');
                if (audioSource) {
                    // Finde das Lied in der Liste
                    const song = baritonSongs.find(s => s.filename === savedFileName);
                    if (song) {
                        audioSource.src = song.path;
                        const audioPlayer = document.getElementById('performanceAudio');
                        if (audioPlayer) {
                            audioPlayer.load();
                        }
                        const fileNameDisplay = document.getElementById('audioFileName');
                        if (fileNameDisplay) {
                            fileNameDisplay.textContent = `üìÄ Aktuelles Lied: ${song.name}`;
                        }
                    } else {
                        // Fallback: Versuche direkt zu laden
                        audioSource.src = `/audio/${savedFileName}`;
                        const audioPlayer = document.getElementById('performanceAudio');
                        if (audioPlayer) {
                            audioPlayer.load();
                        }
                        const fileNameDisplay = document.getElementById('audioFileName');
                        if (fileNameDisplay) {
                            fileNameDisplay.textContent = `üìÄ Aktuelles Lied: ${savedFileName}`;
                        }
                    }
                }
            }
            
            // Lade Lieder Liste
            loadBaritonSongs();
        }

        // Page navigation
        function showPage(pageId) {
            document.querySelectorAll('.page').forEach(page => {
                page.classList.remove('active');
            });
            
            document.querySelectorAll('.nav-btn').forEach(btn => {
                btn.classList.remove('active');
            });
            
            document.getElementById(pageId).classList.add('active');
            if (event && event.target) {
                event.target.classList.add('active');
            }
            
            // Lade Songs wenn Notizen-Seite ge√∂ffnet wird
            if (pageId === 'notes') {
                loadBaritonSongs();
            }
        }

        // Custom Dialog System - Ersetzt alert/confirm/prompt
        let dialogResolve = null;

        function showDialog(header, message, showInput = false, inputValue = '', buttons = []) {
            return new Promise((resolve) => {
                dialogResolve = resolve;
                const modal = document.getElementById('dialogModal');
                const headerEl = document.getElementById('dialogHeader');
                const messageEl = document.getElementById('dialogMessage');
                const inputContainer = document.getElementById('dialogInputContainer');
                const inputEl = document.getElementById('dialogInput');
                const buttonsEl = document.getElementById('dialogButtons');
                
                headerEl.innerText = header || 'Information';
                messageEl.innerText = message || '';
                
                if (showInput) {
                    inputContainer.style.display = 'block';
                    inputEl.value = inputValue;
                    inputEl.focus();
                    inputEl.select();
                    
                    // Enter-Taste best√§tigt
                    const enterHandler = function(e) {
                        if (e.key === 'Enter') {
                            inputEl.removeEventListener('keypress', enterHandler);
                            closeDialog(inputEl.value);
                        }
                    };
                    inputEl.addEventListener('keypress', enterHandler);
                } else {
                    inputContainer.style.display = 'none';
                    inputEl.value = '';
                }
                
                buttonsEl.innerHTML = '';
                if (buttons.length === 0) {
                    // Standard: OK-Button
                    const okBtn = document.createElement('button');
                    okBtn.className = 'dialog-btn dialog-btn-primary';
                    okBtn.innerText = 'OK';
                    okBtn.onclick = () => closeDialog(true);
                    buttonsEl.appendChild(okBtn);
                } else {
                    buttons.forEach(btn => {
                        const btnEl = document.createElement('button');
                        btnEl.className = `dialog-btn ${btn.class}`;
                        btnEl.innerText = btn.text;
                        btnEl.onclick = () => closeDialog(btn.value);
                        buttonsEl.appendChild(btnEl);
                    });
                }
                
                modal.classList.add('active');
            });
        }

        function closeDialog(result) {
            const modal = document.getElementById('dialogModal');
            modal.classList.remove('active');
            if (dialogResolve) {
                dialogResolve(result);
                dialogResolve = null;
            }
        }

        // Schlie√üe Dialog beim Klick au√üerhalb
        document.addEventListener('DOMContentLoaded', function() {
            const modal = document.getElementById('dialogModal');
            if (modal) {
                modal.addEventListener('click', function(e) {
                    if (e.target === modal) {
                        closeDialog(false);
                    }
                });
            }
        });

        // Wrapper-Funktionen
        async function customAlert(message) {
            await showDialog('Information', message, false, '', []);
        }

        async function customConfirm(message) {
            const result = await showDialog('Best√§tigung', message, false, '', [
                {text: 'Abbrechen', class: 'dialog-btn-secondary', value: false},
                {text: 'OK', class: 'dialog-btn-primary', value: true}
            ]);
            return result;
        }

        async function customPrompt(message, defaultValue = '') {
            const result = await showDialog('Eingabe', message, true, defaultValue, [
                {text: 'Abbrechen', class: 'dialog-btn-secondary', value: null},
                {text: 'OK', class: 'dialog-btn-primary', value: true}
            ]);
            if (result === true) {
                return document.getElementById('dialogInput').value;
            }
            return null;
        }

        // ========== CHARACTER MANAGEMENT ==========
        
        // Aktuelle Character ID (aus localStorage oder Standard 1)
        let currentCharacterId = parseInt(localStorage.getItem('currentCharacterId')) || 1;
        let currentCharacterManager = null;
        
        // Character Manager initialisieren
        function initCharacterManager(characterId) {
            currentCharacterId = characterId;
            localStorage.setItem('currentCharacterId', characterId.toString());
            
            // Verwende window.CharacterDataManagerAPI falls verf√ºgbar (von API.js)
            if (typeof window !== 'undefined' && window.CharacterDataManagerAPI) {
                currentCharacterManager = new window.CharacterDataManagerAPI(characterId);
                // Synchronisiere auch mit window.currentCharacterManager (von main.js)
                if (window.currentCharacterManager !== currentCharacterManager) {
                    window.currentCharacterManager = currentCharacterManager;
                }
            } else if (typeof CharacterDataManagerAPI !== 'undefined') {
                currentCharacterManager = new CharacterDataManagerAPI(characterId);
                // Synchronisiere auch mit window.currentCharacterManager (von main.js)
                if (typeof window !== 'undefined' && window.currentCharacterManager !== currentCharacterManager) {
                    window.currentCharacterManager = currentCharacterManager;
                }
            } else {
                console.warn('CharacterDataManagerAPI nicht verf√ºgbar!');
            }
        }
        
        // Character Liste laden und im Select anzeigen
        async function loadCharacterList() {
            const select = document.getElementById('characterSelect');
            if (!select) return;
            
            select.innerHTML = '<option value="">Lade Charaktere...</option>';
            
            try {
                if (typeof apiClient !== 'undefined' && apiClient) {
                    const characters = await apiClient.getAllCharacters();
                    select.innerHTML = '';
                    
                    if (characters && characters.length > 0) {
                        characters.forEach(char => {
                            const option = document.createElement('option');
                            option.value = char.id;
                            option.textContent = `${char.name} (Level ${char.level || 1}) - ${char.class || 'Unbekannt'}`;
                            if (char.id == currentCharacterId) {
                                option.selected = true;
                            }
                            select.appendChild(option);
                        });
                    } else {
                        select.innerHTML = '<option value="">Keine Charaktere gefunden</option>';
                    }
                } else {
                    // Fallback: Nur aktuellen Character anzeigen
                    select.innerHTML = `<option value="${currentCharacterId}">Bar-iton (Level 1) - Barde</option>`;
                }
            } catch (error) {
                console.error('Fehler beim Laden der Character-Liste:', error);
                select.innerHTML = '<option value="">Fehler beim Laden</option>';
            }
        }
        
        // Character wechseln
        async function switchCharacter() {
            const select = document.getElementById('characterSelect');
            if (!select) return;
            
            const newCharacterId = parseInt(select.value);
            
            if (!newCharacterId || newCharacterId === currentCharacterId) {
                return;
            }
            
            // Speichere aktuellen Character zuerst
            if (currentCharacterManager) {
                await currentCharacterManager.save().catch(() => {});
            } else {
                saveCharacterData();
            }
            
            // Initialisiere neuen Character Manager
            initCharacterManager(newCharacterId);
            
            // Lade neuen Character
            await loadCharacter(newCharacterId);
        }
        
        // Character laden
        async function loadCharacter(characterId) {
            // Verwende window.CharacterDataManagerAPI falls verf√ºgbar (von API.js)
            const CharacterDataManagerAPIClass = (typeof window !== 'undefined' && window.CharacterDataManagerAPI) 
                ? window.CharacterDataManagerAPI 
                : (typeof CharacterDataManagerAPI !== 'undefined' ? CharacterDataManagerAPI : null);
                
            if (CharacterDataManagerAPIClass) {
                const apiManager = new CharacterDataManagerAPIClass(characterId);
                try {
                    await apiManager.load();
                    currentCharacterManager = apiManager;
                    // Synchronisiere auch mit window.currentCharacterManager (von main.js)
                    if (typeof window !== 'undefined') {
                        window.currentCharacterManager = apiManager;
                    }
                } catch (err) {
                    console.error('‚ùå API-Laden fehlgeschlagen:', err);
                    console.warn('Wechsle zu localStorage:', err);
                    // Fallback zu localStorage
                    const dataLoaded = loadCharacterData();
                    if (!dataLoaded) {
                        initDefaultCharacter();
                    }
                }
            } else {
                console.warn('CharacterDataManagerAPI nicht verf√ºgbar, verwende localStorage');
                // Fallback zu localStorage
                const dataLoaded = loadCharacterData();
                if (!dataLoaded) {
                    initDefaultCharacter();
                }
            }
        }
        
        // Standard-Character initialisieren
        function initDefaultCharacter() {
            updateXPBar();
            calculateArmorClass();
            updateWeaponsTable();
            updateBardicInspirationCombat();
            updateSpellButtons();
        }
        
        // Character Liste aktualisieren
        function refreshCharacterList() {
            loadCharacterList();
        }
        
        // Modal f√ºr neuen Character anzeigen
        function showCreateCharacterModal() {
            const modal = document.getElementById('createCharacterModal');
            if (modal) {
                modal.classList.add('active');
                const nameInput = document.getElementById('newCharName');
                if (nameInput) nameInput.focus();
            }
        }
        
        // Modal schlie√üen
        function closeCreateCharacterModal() {
            const modal = document.getElementById('createCharacterModal');
            if (modal) {
                modal.classList.remove('active');
                // Felder zur√ºcksetzen
                const nameEl = document.getElementById('newCharName');
                const classEl = document.getElementById('newCharClass');
                const raceEl = document.getElementById('newCharRace');
                const bgEl = document.getElementById('newCharBackground');
                const alignEl = document.getElementById('newCharAlignment');
                const levelEl = document.getElementById('newCharLevel');
                
                if (nameEl) nameEl.value = '';
                if (classEl) classEl.value = 'Barde';
                if (raceEl) raceEl.value = '';
                if (bgEl) bgEl.value = '';
                if (alignEl) alignEl.value = 'CN';
                if (levelEl) levelEl.value = '1';
            }
        }
        
        // Neuen Character erstellen
        async function createCharacter() {
            const nameEl = document.getElementById('newCharName');
            const classEl = document.getElementById('newCharClass');
            const raceEl = document.getElementById('newCharRace');
            const bgEl = document.getElementById('newCharBackground');
            const alignEl = document.getElementById('newCharAlignment');
            const levelEl = document.getElementById('newCharLevel');
            
            if (!nameEl || !classEl || !raceEl || !bgEl || !alignEl || !levelEl) {
                await customAlert('Fehler: Formularfelder nicht gefunden!');
                return;
            }
            
            const name = nameEl.value.trim();
            const className = classEl.value;
            const race = raceEl.value.trim();
            const background = bgEl.value.trim();
            const alignment = alignEl.value;
            const level = parseInt(levelEl.value) || 1;
            
            if (!name) {
                await customAlert('Bitte gib einen Namen f√ºr den Charakter ein!');
                return;
            }
            
            try {
                if (typeof apiClient !== 'undefined' && apiClient) {
                    const result = await apiClient.createCharacter({
                        name: name,
                        class: className,
                        race: race || 'Unbekannt',
                        background: background || 'Unbekannt',
                        alignment: alignment,
                        level: level
                    });
                    
                    if (result && result.id) {
                        await customAlert(`Charakter "${name}" erfolgreich erstellt!`);
                        closeCreateCharacterModal();
                        
                        // Lade Character-Liste neu
                        await loadCharacterList();
                        
                        // Wechsle zu neuem Character
                        const select = document.getElementById('characterSelect');
                        if (select) {
                            select.value = result.id;
                            await switchCharacter();
                        }
                    } else {
                        throw new Error('Keine Character-ID erhalten');
                    }
                } else {
                    await customAlert('API nicht verf√ºgbar. Verwende localStorage f√ºr neue Charaktere.');
                    // TODO: localStorage-Fallback implementieren falls gew√ºnscht
                }
            } catch (error) {
                console.error('Fehler beim Erstellen des Charakters:', error);
                await customAlert(`Fehler beim Erstellen: ${error.message}`);
            }
        }

        // ========== KLASSEN-SYSTEM ==========
        // Character Data Manager - zentrale Speicher- und Ladeverwaltung
        class CharacterDataManager {
            constructor() {
                this.storageKey = 'barItonCharacterData';
                this.data = null;
            }

            // Speichere alle Charakterdaten
            save() {
                const spellSlotManager = new SpellSlotManager();
                const equipmentManager = new EquipmentManager();
                const inventoryManager = new InventoryManager();

                this.data = {
                    // HP & Ressourcen
                    currentHP: this.getElementText('currentHP'),
                    maxHP: this.getElementText('maxHP'),
                    tempHP: this.getElementText('tempHP'),
                    currentBI: this.getElementText('currentBI'),
                    currentHD: this.getElementText('hdTracker', '1'),
                    maxHD: this.getElementText('maxHD', '1'),
                    
                    // XP & Level
                    currentXP: this.getElementText('currentXP'),
                    charLevel: this.getElementText('charLevel'),
                    
                    // Ausr√ºstung
                    armorSlot: equipmentManager.getSlotData('armorSlot'),
                    mainHandSlot: equipmentManager.getSlotData('mainHandSlot'),
                    offHandSlot: equipmentManager.getSlotData('offHandSlot'),
                    
                    // Inventar
                    equipment: inventoryManager.getItems('equipmentList'),
                    consumables: inventoryManager.getItems('consumablesList'),
                    tools: inventoryManager.getItems('toolsList'),
                    treasure: inventoryManager.getTreasureItems(),
                    
                    // Geld
                    gp: this.getElementText('gpTracker'),
                    sp: this.getElementText('spTracker'),
                    cp: this.getElementText('cpTracker'),
                    
                    // Notizen
                    adventureNotes: this.getElementValue('adventureNotes'),
                    characterNotes: this.getElementValue('characterNotes'),
                    performanceNotes: this.getElementValue('performanceNotes'),
                    
                    // Todesrettungsw√ºrfe
                    deathSaves: this.getDeathSaves(),
                    
                    // Zauberpl√§tze
                    spellSlots: spellSlotManager.getSlots(),
                    
                    // Portrait
                    isStageMode: isStageMode
                };
                
                try {
                    localStorage.setItem(this.storageKey, JSON.stringify(this.data));
                    console.log('Daten gespeichert:', {
                        slots: {
                            armor: !!this.data.armorSlot,
                            mainhand: !!this.data.mainHandSlot,
                            offhand: !!this.data.offHandSlot
                        },
                        inventory: {
                            equipment: this.data.equipment?.length || 0,
                            consumables: this.data.consumables?.length || 0,
                            tools: this.data.tools?.length || 0,
                            treasure: this.data.treasure?.length || 0
                        },
                        spellSlots: this.data.spellSlots?.length || 0
                    });
                    return true;
                } catch(e) {
                    console.error('Fehler beim Speichern:', e);
                    return false;
                }
            }

            // Lade alle Charakterdaten
            load() {
                try {
                    const savedData = localStorage.getItem(this.storageKey);
                    if (!savedData) return false;
                    
                    this.data = JSON.parse(savedData);
                    
                    // HP & Ressourcen
                    this.setElementText('currentHP', this.data.currentHP);
                    this.setElementText('maxHP', this.data.maxHP);
                    this.setElementText('tempHP', this.data.tempHP);
                    this.setElementText('currentBI', this.data.currentBI);
                    this.setElementTextIfExists('hdTracker', this.data.currentHD);
                    this.setElementTextIfExists('maxHD', this.data.maxHD);
                    
                    // XP & Level
                    this.setElementText('currentXP', this.data.currentXP);
                    if (this.data.charLevel) {
                        this.loadLevel(this.data.charLevel);
                    }
                    
                    // Ausr√ºstung
                    const equipmentManager = new EquipmentManager();
                    if (this.data.armorSlot) equipmentManager.setSlotData('armorSlot', this.data.armorSlot);
                    if (this.data.mainHandSlot) equipmentManager.setSlotData('mainHandSlot', this.data.mainHandSlot);
                    if (this.data.offHandSlot) equipmentManager.setSlotData('offHandSlot', this.data.offHandSlot);
                    equipmentManager.updateWeaponsTable();
                    calculateArmorClass();
                    
                    // Inventar
                    const inventoryManager = new InventoryManager();
                    if (this.data.equipment) inventoryManager.restoreItems('equipmentList', this.data.equipment);
                    if (this.data.consumables) inventoryManager.restoreItems('consumablesList', this.data.consumables);
                    if (this.data.tools) inventoryManager.restoreItems('toolsList', this.data.tools);
                    if (this.data.treasure) inventoryManager.restoreTreasureItems(this.data.treasure);
                    
                    // Geld
                    this.setElementText('gpTracker', this.data.gp);
                    this.setElementText('spTracker', this.data.sp);
                    this.setElementText('cpTracker', this.data.cp);
                    
                    // Notizen
                    this.setElementValue('adventureNotes', this.data.adventureNotes);
                    this.setElementValue('characterNotes', this.data.characterNotes);
                    this.setElementValue('performanceNotes', this.data.performanceNotes);
                    
                    // Todesrettungsw√ºrfe
                    this.restoreDeathSaves(this.data.deathSaves);
                    
                    // Zauberpl√§tze
                    const spellSlotManager = new SpellSlotManager();
                    if (this.data.spellSlots) {
                        spellSlotManager.restoreSlots(this.data.spellSlots);
                    }
                    
                    // Portrait
                    if (this.data.isStageMode !== undefined && typeof window !== 'undefined' && window.portraits) {
                        isStageMode = this.data.isStageMode;
                        window.isStageMode = this.data.isStageMode;
                        const img = document.getElementById('characterImage');
                        if (img) {
                            img.src = isStageMode ? window.portraits.stage : window.portraits.civil;
                        }
                    }
                    
                    calculateArmorClass();
                    updateXPBar();
                    
                    console.log('Daten geladen:', {
                        slots: {
                            armor: !!this.data.armorSlot,
                            mainhand: !!this.data.mainHandSlot,
                            offhand: !!this.data.offHandSlot
                        },
                        inventory: {
                            equipment: this.data.equipment?.length || 0,
                            consumables: this.data.consumables?.length || 0,
                            tools: this.data.tools?.length || 0,
                            treasure: this.data.treasure?.length || 0
                        },
                        spellSlots: this.data.spellSlots?.length || 0
                    });
                    return true;
                } catch(e) {
                    console.error('Fehler beim Laden:', e);
                    return false;
                }
            }

            // Hilfsmethoden
            getElementText(id, defaultValue = '') {
                const el = document.getElementById(id);
                return el ? el.innerText : defaultValue;
            }

            setElementText(id, value) {
                const el = document.getElementById(id);
                if (el && value !== undefined && value !== null) {
                    el.innerText = value;
                }
            }

            setElementTextIfExists(id, value) {
                const el = document.getElementById(id);
                if (el && value !== undefined && value !== null) {
                    el.innerText = value;
                }
            }

            getElementValue(id) {
                const el = document.getElementById(id);
                return el ? el.value : '';
            }

            setElementValue(id, value) {
                const el = document.getElementById(id);
                if (el && value !== undefined && value !== null) {
                    el.value = value;
                }
            }

            loadLevel(level) {
                const savedLevel = parseInt(level);
                this.setElementText('charLevel', savedLevel);
                document.getElementById('charLevel').setAttribute('data-last-level', String(savedLevel));
                
                const profBonus = Math.floor((savedLevel - 1) / 4) + 2;
                this.setElementText('profBonus', profBonus);
                
                this.setElementTextIfExists('maxHD', savedLevel);
                
                const conMod = 1;
                const baseHP = 8;
                const additionalHP = (savedLevel - 1) * (5 + conMod);
                const newMaxHP = baseHP + conMod + additionalHP;
                this.setElementText('maxHP', newMaxHP);
                if (document.getElementById('maxHP2')) {
                    document.getElementById('maxHP2').innerText = newMaxHP;
                }
            }

            getDeathSaves() {
                const saves = { successes: [], failures: [] };
                for (let i = 1; i <= 3; i++) {
                    const success = document.getElementById('death' + i + 's');
                    const failure = document.getElementById('death' + i + 'f');
                    if (success && success.checked) saves.successes.push(i);
                    if (failure && failure.checked) saves.failures.push(i);
                }
                return saves;
            }

            restoreDeathSaves(saves) {
                if (!saves) return;
                saves.successes?.forEach(i => {
                    const checkbox = document.getElementById('death' + i + 's');
                    if (checkbox) checkbox.checked = true;
                });
                saves.failures?.forEach(i => {
                    const checkbox = document.getElementById('death' + i + 'f');
                    if (checkbox) checkbox.checked = true;
                });
            }
        }

        // Spell Slot Manager - Verwaltung der Zauberpl√§tze
        class SpellSlotManager {
            getSlots() {
                const slots = [];
                const spellSlotElements = Array.from(document.querySelectorAll('.spell-slot'));
                spellSlotElements.forEach(slot => {
                    slots.push(slot.classList.contains('used'));
                });
                return slots;
            }

            restoreSlots(slots) {
                const spellSlotElements = Array.from(document.querySelectorAll('.spell-slot'));
                if (!Array.isArray(slots) || slots.length === 0) {
                    spellSlotElements.forEach(slot => {
                        slot.classList.remove('used');
                    });
                    updateSpellButtons();
                    return;
                }
                spellSlotElements.forEach((slot, index) => {
                    if (index < slots.length && slots[index] === true) {
                        slot.classList.add('used');
                    } else {
                        slot.classList.remove('used');
                    }
                });
                updateSpellButtons();
            }

            toggleSlot(slot) {
                slot.classList.toggle('used');
                updateSpellButtons();
                characterDataManager.save();
            }

            resetSlots() {
                document.querySelectorAll('.spell-slot').forEach(slot => {
                    slot.classList.remove('used');
                });
                updateSpellButtons();
                characterDataManager.save();
            }
        }

        // Equipment Manager - Verwaltung der Ausr√ºstungs-Slots
        class EquipmentManager {
            getSlotData(slotId) {
                const slotItem = document.getElementById(slotId + 'Item');
                if (slotItem && slotItem.classList.contains('slot-item')) {
                    const itemData = slotItem.getAttribute('data-item');
                    if (itemData) {
                        try {
                            return JSON.parse(itemData);
                        } catch(e) {
                            return null;
                        }
                    }
                }
                return null;
            }

            setSlotData(slotId, itemData) {
                const slotItem = document.getElementById(slotId + 'Item');
                if (!slotItem) return;
                
                if (!itemData) {
                    // Leerer Slot - zur√ºcksetzen
                    slotItem.className = 'slot-placeholder';
                    slotItem.innerText = slotId === 'armorSlot' ? 'Keine R√ºstung' : 'Leer';
                    slotItem.removeAttribute('data-item');
                    
                    // Reaktiviere offhand Slot falls 2h-Waffe entfernt wurde
                    if (slotId === 'mainHandSlot') {
                        const offHandSlotContainer = document.getElementById('offHandSlot');
                        if (offHandSlotContainer) {
                            offHandSlotContainer.style.opacity = '1';
                            offHandSlotContainer.style.pointerEvents = 'auto';
                            offHandSlotContainer.removeAttribute('data-disabled');
                        }
                    }
                    return;
                }
                
                // Item in Slot setzen
                slotItem.className = 'slot-item';
                slotItem.innerText = itemData.name || 'Unbekannt';
                slotItem.setAttribute('data-item', JSON.stringify(itemData));
                
                // Aktualisiere 2h-Waffe Logik
                if (itemData.hands === '2h') {
                    const offHandSlotContainer = document.getElementById('offHandSlot');
                    const offHandSlotItem = document.getElementById('offHandSlotItem');
                    if (offHandSlotContainer) {
                        if (offHandSlotItem && offHandSlotItem.classList.contains('slot-item')) {
                            offHandSlotItem.className = 'slot-placeholder';
                            offHandSlotItem.innerText = 'Leer';
                            offHandSlotItem.removeAttribute('data-item');
                        }
                        offHandSlotContainer.style.opacity = '0.5';
                        offHandSlotContainer.style.pointerEvents = 'none';
                        offHandSlotContainer.setAttribute('data-disabled', 'true');
                    }
                } else {
                    const offHandSlotContainer = document.getElementById('offHandSlot');
                    if (offHandSlotContainer && slotId === 'mainHandSlot') {
                        offHandSlotContainer.style.opacity = '1';
                        offHandSlotContainer.style.pointerEvents = 'auto';
                        offHandSlotContainer.removeAttribute('data-disabled');
                    }
                }
                
                if (slotId === 'armorSlot') {
                    calculateArmorClass();
                }
                if (itemData.type === 'weapon') {
                    this.updateWeaponsTable();
                }
            }

            updateWeaponsTable() {
                const mainHandSlot = document.getElementById('mainHandSlotItem');
                const offHandSlot = document.getElementById('offHandSlotItem');
                const mainHandRow = document.getElementById('mainHandWeapon');
                const offHandRow = document.getElementById('offHandWeapon');
                
                if (mainHandSlot && mainHandSlot.classList.contains('slot-item')) {
                    try {
                        const itemData = mainHandSlot.getAttribute('data-item');
                        const item = JSON.parse(itemData);
                        mainHandRow.innerHTML = `
                            <td>${item.name} (Haupthand)</td>
                            <td>${item.toHit || '+4'}</td>
                            <td>${item.damage || '1d4+2'}</td>
                            <td>${item.range || '1,5m'}</td>
                        `;
                    } catch(e) {
                        mainHandRow.innerHTML = `<td>-</td><td>-</td><td>-</td><td>-</td>`;
                    }
                } else {
                    mainHandRow.innerHTML = `<td>-</td><td>-</td><td>-</td><td>-</td>`;
                }
                
                if (offHandSlot && offHandSlot.classList.contains('slot-item')) {
                    try {
                        const itemData = offHandSlot.getAttribute('data-item');
                        const item = JSON.parse(itemData);
                        const damage = item.offhandDamage || item.damage || '1d4';
                        offHandRow.style.display = '';
                        offHandRow.innerHTML = `
                            <td>${item.name} (Nebenhand)</td>
                            <td>${item.toHit || '+4'}</td>
                            <td>${damage}</td>
                            <td>${item.range || '1,5m'}</td>
                        `;
                    } catch(e) {
                        offHandRow.style.display = 'none';
                        offHandRow.innerHTML = `<td>-</td><td>-</td><td>-</td><td>-</td>`;
                    }
                } else {
                    offHandRow.style.display = 'none';
                    offHandRow.innerHTML = `<td>-</td><td>-</td><td>-</td><td>-</td>`;
                }
            }
        }

        // Inventory Manager - Verwaltung des Inventars
        class InventoryManager {
            getItems(listId) {
                const list = document.getElementById(listId);
                const items = [];
                if (!list) return items;
                list.querySelectorAll('.inventory-item').forEach(item => {
                    const itemData = item.getAttribute('data-item');
                    if (itemData) {
                        try {
                            items.push(JSON.parse(itemData));
                        } catch(e) {
                            // Ignoriere fehlerhafte Items
                        }
                    }
                });
                return items;
            }

            getTreasureItems() {
                const list = document.getElementById('treasureList');
                const items = [];
                if (!list) return items;
                list.querySelectorAll('.treasure-item').forEach(item => {
                    const itemData = item.getAttribute('data-item');
                    if (itemData) {
                        try {
                            items.push(JSON.parse(itemData));
                        } catch(e) {
                            // Ignoriere fehlerhafte Items
                        }
                    }
                });
                return items;
            }

            restoreItems(listId, items) {
                const list = document.getElementById(listId);
                if (!list) return;
                list.innerHTML = '';
                items.forEach(item => {
                    if (listId === 'equipmentList') {
                        const itemElement = createInventoryItemElement(item);
                        list.appendChild(itemElement);
                    } else {
                        const itemElement = document.createElement('div');
                        itemElement.className = 'inventory-item';
                        itemElement.setAttribute('data-item', JSON.stringify(item));
                        const icon = listId === 'consumablesList' ? 'üß™' : 'üì¶';
                        itemElement.innerHTML = `
                            <span>${icon} ${item.name}</span>
                            <div class="item-controls">
                                <button class="btn-remove" onclick="removeInventoryItem(this, '${listId === 'consumablesList' ? 'consumables' : 'tools'}')">√ó</button>
                            </div>
                        `;
                        list.appendChild(itemElement);
                    }
                });
            }

            restoreTreasureItems(items) {
                const list = document.getElementById('treasureList');
                if (!list) return;
                list.innerHTML = '';
                items.forEach(item => {
                    const itemElement = document.createElement('div');
                    itemElement.className = 'treasure-item';
                    itemElement.setAttribute('data-item', JSON.stringify(item));
                    itemElement.setAttribute('draggable', 'false');
                    itemElement.innerHTML = `
                        <span>${item.name}</span>
                        <span class="treasure-value">${item.value}</span>
                        <button class="btn-remove" onclick="removeTreasureItem(this)">√ó</button>
                    `;
                    list.appendChild(itemElement);
                });
            }
        }

        // Globale Instanz
        const characterDataManager = new CharacterDataManager();

        // ========== ALTE FUNKTIONEN - WERDEN SCHRITTWEISE UMGESTELLT ==========
        
        // Level up system
        const xpThresholds = [0, 300, 900, 2700, 6500, 14000, 23000, 34000, 48000, 64000, 85000, 100000, 120000, 140000, 165000, 195000, 225000, 265000, 305000, 355000];

        function adjustXP(amount) {
            const xpElement = document.getElementById('currentXP');
            let current = parseInt(xpElement.innerText);
            let newValue = Math.max(0, current + amount);
            xpElement.innerText = newValue;
            updateXPBar();
            checkLevelUp(newValue);
            updateAllStats();
            saveCharacterData();
        }

        function updateXPBar() {
            const current = parseInt(document.getElementById('currentXP').innerText);
            const currentLevel = parseInt(document.getElementById('charLevel').innerText);
            const nextLevelXP = xpThresholds[currentLevel];
            const prevLevelXP = currentLevel > 1 ? xpThresholds[currentLevel - 1] : 0;
            
            const progress = ((current - prevLevelXP) / (nextLevelXP - prevLevelXP)) * 100;
            document.getElementById('xpBar').style.width = progress + '%';
            document.getElementById('xpBar').innerText = Math.floor(progress) + '%';
            document.getElementById('nextLevelXP').innerText = nextLevelXP;
        }

        function checkLevelUp(xp) {
            let newLevel = 1;
            for(let i = 1; i < xpThresholds.length; i++) {
                if(xp >= xpThresholds[i]) {
                    newLevel = i + 1;
                } else {
                    break;
                }
            }
            
            const currentLevel = parseInt(document.getElementById('charLevel').innerText);
            if(newLevel > currentLevel) {
                levelUp(newLevel);
            }
        }

        let levelUpInProgress = false; // Verhindert doppelte Aufrufe beim Laden

        function levelUp(newLevel) {
            if (levelUpInProgress) return;
            levelUpInProgress = true;
            
            document.getElementById('charLevel').innerText = newLevel;
            
            // Update proficiency bonus
            const profBonus = Math.floor((newLevel - 1) / 4) + 2;
            document.getElementById('profBonus').innerText = profBonus;
            
            // Update hit dice - nur wenn Element existiert
            const maxHDElement = document.getElementById('maxHD');
            if (maxHDElement) {
                maxHDElement.innerText = newLevel;
            }
            
            // Calculate new max HP (add 1d8 + CON modifier per level)
            const conMod = 1; // CON modifier
            const baseHP = 8; // Starting HP at level 1
            const additionalHP = (newLevel - 1) * (5 + conMod); // Average of d8 (4.5 rounded to 5) + CON
            const newMaxHP = baseHP + conMod + additionalHP;
            
            document.getElementById('maxHP').innerText = newMaxHP;
            document.getElementById('maxHP2').innerText = newMaxHP;
            
            saveCharacterData();
            levelUpInProgress = false;
            
            // Nur Alert beim tats√§chlichen Level-Up, nicht beim Laden
            if (document.getElementById('charLevel').getAttribute('data-last-level') !== String(newLevel)) {
                document.getElementById('charLevel').setAttribute('data-last-level', String(newLevel));
                customAlert(`Level Up! Du bist jetzt Level ${newLevel}!\n\nNeue maximale TP: ${newMaxHP}\nGe√ºbtheitsbonus: +${profBonus}`);
            }
        }

        // ========== EDIT MODE ==========
        let editMode = false;
        
        // Edit-Mode Toggle
        function toggleEditMode() {
            editMode = !editMode;
            document.body.classList.toggle('edit-mode', editMode);
            const statusEl = document.getElementById('editModeStatus');
            if (statusEl) {
                statusEl.innerText = editMode ? 'AN' : 'AUS';
            }
            const toggleBtn = document.getElementById('editModeToggle');
            if (toggleBtn) {
                toggleBtn.style.background = editMode 
                    ? 'linear-gradient(135deg, #ff6b6b, #ee5a6f)'
                    : 'linear-gradient(135deg, #9e9e9e, #757575)';
            }
            
            // Mache alle Stat-Werte editierbar im Edit-Mode
            if (editMode) {
                makeStatsEditable();
            } else {
                makeStatsReadOnly();
            }
            
            saveCharacterData();
        }
        
        // Mache Stats editierbar
        function makeStatsEditable() {
            // Attribute (STR, DEX, CON, etc.) editierbar machen
            document.querySelectorAll('.stat-value').forEach(stat => {
                if (!stat.hasAttribute('data-editable')) {
                    stat.setAttribute('contenteditable', 'true');
                    stat.setAttribute('data-editable', 'true');
                    stat.addEventListener('blur', function() {
                        // Validiere Wert
                        const value = parseInt(this.innerText) || 10;
                        if (value < 1) this.innerText = 1;
                        if (value > 30) this.innerText = 30;
                        
                        updateStatModifiers();
                        updateAllStats();
                        saveCharacterData();
                    });
                    stat.addEventListener('input', function() {
                        // Nur Zahlen erlauben
                        this.innerText = this.innerText.replace(/[^0-9]/g, '');
                        updateStatModifiers();
                    });
                }
            });
            
            // Maximalwerte und Namen editierbar machen
            document.querySelectorAll('.max-value').forEach(element => {
                if (!element.hasAttribute('data-editable-max')) {
                    element.setAttribute('contenteditable', 'true');
                    element.setAttribute('data-editable-max', 'true');
                    element.addEventListener('blur', function() {
                        // Validiere je nach Element
                        const id = this.id;
                        if (id === 'maxHP' || id === 'maxBI' || id === 'charLevel' || id === 'profBonus') {
                            const value = parseInt(this.innerText) || 1;
                            if (value < 1) this.innerText = 1;
                            if (id === 'charLevel' && value > 20) this.innerText = 20;
                            updateAllStats();
                        }
                        saveCharacterData();
                    });
                    if (element.id === 'maxHP' || element.id === 'maxBI' || element.id === 'charLevel' || element.id === 'profBonus') {
                        element.addEventListener('input', function() {
                            // Nur Zahlen erlauben
                            this.innerText = this.innerText.replace(/[^0-9]/g, '');
                        });
                    }
                }
            });
        }
        
        // Mache Stats read-only
        function makeStatsReadOnly() {
            document.querySelectorAll('.stat-value[data-editable]').forEach(stat => {
                stat.removeAttribute('contenteditable');
                stat.removeAttribute('data-editable');
            });
            
            // Maximalwerte read-only machen
            document.querySelectorAll('.max-value[data-editable-max]').forEach(element => {
                element.removeAttribute('contenteditable');
                element.removeAttribute('data-editable-max');
            });
        }
        
        // Berechne Stat-Modifikatoren
        function updateStatModifiers() {
            const stats = ['STR', 'DEX', 'CON', 'INT', 'WIS', 'CHA'];
            stats.forEach(statName => {
                const statEl = document.getElementById('stat' + statName);
                const modEl = document.getElementById('mod' + statName);
                if (statEl && modEl) {
                    const value = parseInt(statEl.innerText) || 10;
                    const modifier = Math.floor((value - 10) / 2);
                    modEl.innerText = modifier >= 0 ? '+' + modifier : modifier.toString();
                }
            });
        }
        
        // Aktualisiere alle Stats (wird nach √Ñnderungen aufgerufen)
        function updateAllStats() {
            // Aktualisiere Stat-Modifikatoren
            updateStatModifiers();
            
            // Aktualisiere abh√§ngige Werte
            calculateArmorClass();
            updateWeaponsTable();
            updateXPBar();
            updateBardicInspirationCombat();
            updateSpellButtons();
        }

        // HP Management - hpTracker existiert nicht, verwende currentHP
        function adjustHP(amount) {
            const currentHPElement = document.getElementById('currentHP');
            const tempHPElement = document.getElementById('tempHP');
            const maxHP = parseInt(document.getElementById('maxHP').innerText);
            let current = parseInt(currentHPElement.innerText) || 0;
            let tempHP = parseInt(tempHPElement.innerText) || 0;
            
            if (amount < 0) {
                // Schaden: Ziehe zuerst von Temp-HP ab
                let damage = Math.abs(amount);
                if (tempHP > 0) {
                    const tempDamage = Math.min(tempHP, damage);
                    tempHP -= tempDamage;
                    damage -= tempDamage;
                    tempHPElement.innerText = tempHP;
                }
                // Restlicher Schaden geht auf normale HP
                current = Math.max(0, current - damage);
            } else {
                // Heilung: Max-HP nicht √ºberschreiten
                current = Math.min(maxHP, current + amount);
            }
            
            currentHPElement.innerText = current;
            updateAllStats();
            saveCharacterData();
        }

        function healToMax() {
            const maxHP = parseInt(document.getElementById('maxHP').innerText);
            document.getElementById('currentHP').innerText = maxHP;
            saveCharacterData();
        }

        // Kurze Rast (Short Rest) - 1 Stunde
        async function takeShortRest() {
            const hdElement = document.getElementById('hdTracker');
            const maxHDElement = document.getElementById('maxHD');
            if (!hdElement || !maxHDElement) {
                await customAlert('Trefferw√ºrfel-Elemente nicht gefunden!');
                return;
            }
            
            const currentHD = parseInt(hdElement.innerText) || 1;
            const maxHD = parseInt(maxHDElement.innerText) || 1;
            
            if (currentHD <= 0) {
                await customAlert('Keine Trefferw√ºrfel mehr verf√ºgbar f√ºr eine Kurze Rast!');
                return;
            }
            
            const confirmed = await customConfirm('Kurze Rast nehmen? (1 Stunde)\n\nDu kannst Trefferw√ºrfel verwenden, um HP zu regenerieren.\nBardische Inspiration wird regeneriert.');
            if (!confirmed) {
                return;
            }
            
            // Frage nach Anzahl der zu verwendenden Trefferw√ºrfel
            const hdToUse = await customPrompt(`Wie viele Trefferw√ºrfel m√∂chtest du verwenden? (Verf√ºgbar: ${currentHD})\n\nPro W√ºrfel: 1W8 + 1 (KON-Modifikator)`, '1');
            
            if (hdToUse === null) return; // Abgebrochen
            
            const numHD = parseInt(hdToUse);
            
            if (isNaN(numHD) || numHD < 1 || numHD > currentHD) {
                await customAlert(`Bitte gib eine Zahl zwischen 1 und ${currentHD} ein!`);
                return;
            }
            
            // Heile mit Trefferw√ºrfeln (durchschnittlich 4.5 pro W8, aufgerundet auf 5, +1 CON = 6 pro W√ºrfel)
            // Alternativ: W√ºrfeln lassen oder Durchschnitt verwenden
            const conMod = 1; // CON Modifier
            const avgHealingPerHD = 5 + conMod; // Durchschnitt von 1d8 (4.5 aufgerundet) + CON
            const totalHealing = numHD * avgHealingPerHD;
            
            const currentHP = parseInt(document.getElementById('currentHP').innerText);
            const maxHP = parseInt(document.getElementById('maxHP').innerText);
            const newHP = Math.min(maxHP, currentHP + totalHealing);
            
            // Update HP - hpTracker existiert nicht, verwende currentHP
            document.getElementById('currentHP').innerText = newHP;
            
            // Verwendete Trefferw√ºrfel abziehen
            adjustHD(-numHD);
            
            // Bardische Inspiration regenerieren (Barde: alle BI bei kurzer Rast)
            document.getElementById('currentBI').innerText = '3';
            updateBardicInspirationCombat();
            
            saveCharacterData();
            await customAlert(`Kurze Rast abgeschlossen!\n\nHeilung: +${totalHealing} TP (${numHD}x 1W8+1)\nVerwendete Trefferw√ºrfel: ${numHD}\nBardische Inspiration regeneriert!`);
        }

        // Lange Rast (Long Rest) - 8 Stunden
        async function takeLongRest() {
            const confirmed = await customConfirm('Lange Rast nehmen? (8 Stunden)\n\n- Alle Trefferpunkte werden vollst√§ndig wiederhergestellt\n- Die H√§lfte der maximalen Trefferw√ºrfel wird regeneriert (aufgerundet)\n- Alle Zauberpl√§tze werden wiederhergestellt\n- Bardische Inspiration wird regeneriert');
            if (!confirmed) {
                return;
            }
            
            // Alle HP auf Maximum
            const maxHP = parseInt(document.getElementById('maxHP').innerText);
            document.getElementById('currentHP').innerText = maxHP;
            
            // Tempor√§re HP zur√ºcksetzen
            document.getElementById('tempHP').innerText = '0';
            
            // H√§lfte der maximalen Trefferw√ºrfel regenerieren (aufgerundet)
            const maxHDElement = document.getElementById('maxHD');
            const hdElement = document.getElementById('hdTracker');
            if (maxHDElement && hdElement) {
                const maxHD = parseInt(maxHDElement.innerText);
                const regeneratedHD = Math.ceil(maxHD / 2);
                hdElement.innerText = regeneratedHD;
            }
            
            // Alle Zauberpl√§tze regenerieren
            document.querySelectorAll('.spell-slot').forEach(slot => {
                slot.classList.remove('used');
            });
            updateSpellButtons();
            // Speichere direkt nach Regeneration
            saveCharacterData();
            
            // Bardische Inspiration regenerieren
            document.getElementById('currentBI').innerText = '3';
            updateBardicInspirationCombat();
            
            updateAllStats();
            saveCharacterData();
            const regeneratedHD = maxHDElement ? Math.ceil(parseInt(maxHDElement.innerText) / 2) : 0;
            const maxHD = maxHDElement ? parseInt(maxHDElement.innerText) : 0;
            await customAlert(`Lange Rast abgeschlossen!\n\n‚úì Alle Trefferpunkte wiederhergestellt\n‚úì ${regeneratedHD} Trefferw√ºrfel regeneriert (von ${maxHD} max)\n‚úì Alle Zauberpl√§tze wiederhergestellt\n‚úì Bardische Inspiration regeneriert`);
        }

        // Level-Up r√ºckg√§ngig machen
        async function undoLevelUp() {
            const currentLevel = parseInt(document.getElementById('charLevel').innerText);
            
            if (currentLevel <= 1) {
                await customAlert('Du kannst nicht unter Level 1 gehen!');
                return;
            }
            
            const confirmed = await customConfirm(`Level-Up wirklich r√ºckg√§ngig machen?\n\nDu wirst von Level ${currentLevel} auf Level ${currentLevel - 1} zur√ºckgesetzt.\n\nDiese Aktion kann nicht r√ºckg√§ngig gemacht werden!`);
            if (!confirmed) {
                return;
            }
            
            const newLevel = currentLevel - 1;
            
            // Setze Level
            document.getElementById('charLevel').innerText = newLevel;
            document.getElementById('charLevel').setAttribute('data-last-level', String(newLevel));
            
            // Update proficiency bonus
            const profBonus = Math.floor((newLevel - 1) / 4) + 2;
            document.getElementById('profBonus').innerText = profBonus;
            
            // Update hit dice - nur wenn Element existiert
            const maxHDElement = document.getElementById('maxHD');
            if (maxHDElement) {
                maxHDElement.innerText = newLevel;
            }
            
            // Reduce max HP
            const conMod = 1; // CON modifier
            const baseHP = 8; // Starting HP at level 1
            const additionalHP = (newLevel - 1) * (5 + conMod); // Average of d8 (4.5 rounded to 5) + CON
            const newMaxHP = baseHP + conMod + additionalHP;
            
            const oldMaxHP = parseInt(document.getElementById('maxHP').innerText);
            document.getElementById('maxHP').innerText = newMaxHP;
            document.getElementById('maxHP2').innerText = newMaxHP;
            
            // Wenn aktuelle HP √ºber dem neuen Maximum liegt, reduziere sie
            const currentHP = parseInt(document.getElementById('currentHP').innerText);
            if (currentHP > newMaxHP) {
                document.getElementById('hpTracker').innerText = newMaxHP;
                document.getElementById('currentHP').innerText = newMaxHP;
            }
            
            // Setze XP auf das vorherige Level-Threshold
            const prevLevelXP = xpThresholds[newLevel - 1];
            document.getElementById('currentXP').innerText = prevLevelXP;
            
            // Update XP Bar
            updateXPBar();
            
            updateAllStats();
            saveCharacterData();
            await customAlert(`Level-Up r√ºckg√§ngig gemacht!\n\nDu bist jetzt Level ${newLevel}.\nMaximale TP: ${newMaxHP} (vorher: ${oldMaxHP})\nGe√ºbtheitsbonus: +${profBonus}\nXP: ${prevLevelXP}`);
        }

        // Bardic Inspiration Management
        function adjustBI(amount) {
            const biElement = document.getElementById('biTracker');
            const currentBIElement = document.getElementById('currentBI');
            let current = parseInt(currentBIElement.innerText) || 0;
            let newValue = Math.max(0, Math.min(3, current + amount));
            currentBIElement.innerText = newValue;
            if (biElement) biElement.innerText = newValue;
            updateBardicInspirationCombat();
            updateAllStats();
            saveCharacterData();
        }

        // Hit Dice Management - nur wenn Element existiert
        function adjustHD(amount) {
            const hdElement = document.getElementById('hdTracker');
            const maxHDElement = document.getElementById('maxHD');
            if (!hdElement || !maxHDElement) return;
            
            const maxHD = parseInt(maxHDElement.innerText);
            let current = parseInt(hdElement.innerText) || 0;
            let newValue = Math.max(0, Math.min(maxHD, current + amount));
            hdElement.innerText = newValue;
            updateAllStats();
            saveCharacterData();
        }

        // Gold Management
        function adjustGold(type, amount) {
            const element = document.getElementById(type + 'Tracker');
            let current = parseInt(element.innerText);
            let newValue = Math.max(0, current + amount);
            element.innerText = newValue;
            updateAllStats();
            saveCharacterData();
        }

        // Spell Slot Management - jetzt √ºber SpellSlotManager
        function toggleSpellSlot(slot) {
            const spellSlotManager = new SpellSlotManager();
            spellSlotManager.toggleSlot(slot);
            updateAllStats();
            saveCharacterData();
        }

        function resetSpellSlots() {
            const spellSlotManager = new SpellSlotManager();
            spellSlotManager.resetSlots();
            updateAllStats();
            saveCharacterData();
        }

        // Death Saves
        function resetDeathSaves() {
            document.querySelectorAll('[id^="death"]').forEach(checkbox => {
                checkbox.checked = false;
            });
            updateAllStats();
            saveCharacterData();
        }
        
        // Death Save Toggle (f√ºr Checkboxen) - wird im window.load initialisiert

        // Quick HP Management (direkt in Quick-Stats)
        function adjustQuickHP(amount) {
            const hpElement = document.getElementById('currentHP');
            const hpTracker = document.getElementById('hpTracker');
            const tempHPElement = document.getElementById('tempHP');
            const maxHP = parseInt(document.getElementById('maxHP').innerText);
            let current = parseInt(hpElement.innerText);
            let tempHP = parseInt(tempHPElement.innerText) || 0;
            
            if (amount < 0) {
                // Schaden: Ziehe zuerst von Temp-HP ab
                let damage = Math.abs(amount);
                if (tempHP > 0) {
                    const tempDamage = Math.min(tempHP, damage);
                    tempHP -= tempDamage;
                    damage -= tempDamage;
                    tempHPElement.innerText = tempHP;
                }
                // Restlicher Schaden geht auf normale HP
                current = Math.max(0, current - damage);
            } else {
                // Heilung: Max-HP nicht √ºberschreiten
                current = Math.min(maxHP, current + amount);
            }
            
            hpElement.innerText = current;
            if (hpTracker) hpTracker.innerText = current;
            saveCharacterData();
        }

        // Temporary HP Management
        function adjustTempHP(amount) {
            const tempHPElement = document.getElementById('tempHP');
            let current = parseInt(tempHPElement.innerText) || 0;
            let newValue = Math.max(0, current + amount);
            tempHPElement.innerText = newValue;
            saveCharacterData();
        }

        // Armor Class Calculation
        function calculateArmorClass() {
            const armorSlot = document.getElementById('armorSlotItem');
            let ac = 10; // Base AC
            
            // Charisma modifier (f√ºr Barde Unarmored Defense)
            const chaMod = 3; // CHA 17 = +3 Modifier
            const dexMod = 2; // DEX 15 = +2 Modifier
            
            // Pr√ºfe ob R√ºstung angelegt ist
            if (armorSlot && armorSlot.classList.contains('slot-item')) {
                const itemData = armorSlot.getAttribute('data-item');
                if (itemData) {
                    try {
                        const item = JSON.parse(itemData);
                        if (item.type === 'armor' && item.ac !== undefined && item.ac !== null) {
                            // R√ºstung angelegt
                            ac = parseInt(item.ac);
                            
                            // Pr√ºfe ob DEX-Bonus erlaubt ist
                            if (item.dexBonus === true || (item.dexBonus !== false && item.dexBonus !== undefined)) {
                                // Maximale DEX-Bonus f√ºr R√ºstungen (z.B. bei Lederr√ºstung +5)
                                const maxDex = item.maxDexBonus !== undefined ? parseInt(item.maxDexBonus) : 10;
                                const dexBonus = Math.min(dexMod, maxDex);
                                ac += dexBonus;
                                document.getElementById('armorACInfo').innerText = `AC: ${item.ac} + DEX (max ${maxDex}) = ${ac}`;
                            } else {
                                // R√ºstung ohne DEX-Bonus (z.B. Plattenr√ºstung)
                                document.getElementById('armorACInfo').innerText = `AC: ${ac}`;
                            }
                        } else {
                            // Item ist keine R√ºstung, verwende Unarmored Defense
                            ac = 10 + dexMod + chaMod;
                            document.getElementById('armorACInfo').innerText = 'AC: 10 + DEX + CHA';
                        }
                    } catch(e) {
                        console.error('Fehler beim Parsen der R√ºstung:', e);
                        // Fehler beim Parsen, verwende Unarmored Defense
                        ac = 10 + dexMod + chaMod;
                        document.getElementById('armorACInfo').innerText = 'AC: 10 + DEX + CHA';
                    }
                } else {
                    // Keine Item-Daten, verwende Unarmored Defense
                    ac = 10 + dexMod + chaMod;
                    document.getElementById('armorACInfo').innerText = 'AC: 10 + DEX + CHA';
                }
            } else {
                // Keine R√ºstung angelegt, verwende Unarmored Defense (Barde)
                ac = 10 + dexMod + chaMod;
                document.getElementById('armorACInfo').innerText = 'AC: 10 + DEX + CHA';
            }
            
            document.getElementById('armorClassDisplay').innerText = ac;
            saveCharacterData();
            return ac;
        }

        // Drag & Drop f√ºr Ausr√ºstung
        let draggedItemElement = null; // Speichert das gezogene Item-Element

        function dragItem(event) {
            const itemElement = event.target.closest('.inventory-item');
            if (itemElement) {
                event.dataTransfer.setData('text/plain', itemElement.getAttribute('data-item'));
                event.dataTransfer.setData('item-element-id', itemElement.getAttribute('data-item-id') || '');
                draggedItemElement = itemElement; // Speichere das Element f√ºr sp√§ter
                itemElement.classList.add('dragging');
            }
        }

        function allowDrop(event) {
            event.preventDefault();
            if (event.type === 'dragover') {
                event.currentTarget.classList.add('drag-over');
            }
        }

        function dropItem(event) {
            event.preventDefault();
            event.currentTarget.classList.remove('drag-over');
            
            const itemData = event.dataTransfer.getData('text/plain');
            if (!itemData || !draggedItemElement) return;
            
            const slotType = event.currentTarget.getAttribute('data-slot');
            const slotId = event.currentTarget.id;
            const slotItemElement = document.getElementById(slotId + 'Item');
            
            try {
                const item = JSON.parse(itemData);
                
                // Pr√ºfe ob Item f√ºr diesen Slot geeignet ist
                if (slotType === 'armor' && item.type !== 'armor') {
                    customAlert('Nur R√ºstung kann hier angelegt werden!');
                    document.querySelectorAll('.dragging').forEach(el => el.classList.remove('dragging'));
                    draggedItemElement = null;
                    return;
                }
                if ((slotType === 'mainhand' || slotType === 'offhand') && item.type !== 'weapon') {
                    customAlert('Nur Waffen k√∂nnen hier angelegt werden!');
                    document.querySelectorAll('.dragging').forEach(el => el.classList.remove('dragging'));
                    draggedItemElement = null;
                    return;
                }
                
                // Pr√ºfe ob 2h-Waffe angelegt wird - graue offhand Slot aus
                if (item.hands === '2h') {
                    const offHandSlotContainer = document.getElementById('offHandSlot');
                    const offHandSlotItem = document.getElementById('offHandSlotItem');
                    if (offHandSlotContainer && offHandSlotItem.classList.contains('slot-item')) {
                        // Wenn offhand Item vorhanden, zur√ºck ins Inventar
                        const offHandData = offHandSlotItem.getAttribute('data-item');
                        if (offHandData) {
                            try {
                                const offHandItem = JSON.parse(offHandData);
                                const equipmentList = document.getElementById('equipmentList');
                                const returnItem = createInventoryItemElement(offHandItem);
                                equipmentList.appendChild(returnItem);
                            } catch(e) {
                                console.error('Fehler beim Zur√ºckgeben:', e);
                            }
                        }
                        offHandSlotItem.className = 'slot-placeholder';
                        offHandSlotItem.innerText = 'Leer';
                        offHandSlotItem.removeAttribute('data-item');
                        offHandSlotItem.onclick = null;
                    }
                    if (offHandSlotContainer) {
                        offHandSlotContainer.style.opacity = '0.5';
                        offHandSlotContainer.style.pointerEvents = 'none';
                        offHandSlotContainer.setAttribute('data-disabled', 'true');
                    }
                } else {
                    // 1h-Waffe - offhand Slot aktivieren
                    const offHandSlotContainer = document.getElementById('offHandSlot');
                    if (offHandSlotContainer) {
                        offHandSlotContainer.style.opacity = '1';
                        offHandSlotContainer.style.pointerEvents = 'auto';
                        offHandSlotContainer.removeAttribute('data-disabled');
                    }
                }
                
                // Pr√ºfe ob kleine Waffe in offhand angelegt werden kann
                if (slotType === 'offhand') {
                    const mainHandItem = document.getElementById('mainHandSlotItem');
                    const mainHandData = mainHandItem.getAttribute('data-item');
                    if (!item.light && mainHandData) {
                        try {
                            const mainHandWeapon = JSON.parse(mainHandData);
                            if (!mainHandWeapon.light) {
                                customAlert('Nur leichte Waffen k√∂nnen in der Nebenhand ausger√ºstet werden, wenn die Hauptwaffe nicht leicht ist!');
                                document.querySelectorAll('.dragging').forEach(el => el.classList.remove('dragging'));
                                draggedItemElement = null;
                                return;
                            }
                        } catch(e) {
                            // Ignoriere Fehler
                        }
                    }
                }
                
                // Pr√ºfe ob 2h-Waffe in offhand angelegt werden soll
                if (slotType === 'offhand' && item.hands === '2h') {
                    customAlert('Eine Zweihand-Waffe kann nicht in der Nebenhand ausger√ºstet werden!');
                    document.querySelectorAll('.dragging').forEach(el => el.classList.remove('dragging'));
                    draggedItemElement = null;
                    return;
                }
                
                // Item aus vorherigem Slot zur√ºck ins Inventar falls vorhanden
                let previousItemData = null;
                if (slotItemElement.classList.contains('slot-item')) {
                    previousItemData = slotItemElement.getAttribute('data-item');
                    // F√ºge altes Item zur√ºck ins Inventar ein
                    if (previousItemData) {
                        try {
                            const prevItem = JSON.parse(previousItemData);
                            const equipmentList = document.getElementById('equipmentList');
                            const returnItem = createInventoryItemElement(prevItem);
                            equipmentList.appendChild(returnItem);
                        } catch(e) {
                            console.error('Fehler beim Zur√ºckgeben:', e);
                        }
                    }
                }
                
                // Setze neues Item in Slot
                slotItemElement.className = 'slot-item';
                slotItemElement.innerText = item.name;
                slotItemElement.setAttribute('data-item', itemData);
                
                // Entferne gezogenes Item aus Inventar (nur wenn es nicht aus einem anderen Slot kommt)
                if (draggedItemElement && draggedItemElement.parentNode && !draggedItemElement.closest('.slot-container')) {
                    draggedItemElement.remove();
                }
                
                // Entferne dragging Klasse
                document.querySelectorAll('.dragging').forEach(el => el.classList.remove('dragging'));
                draggedItemElement = null;
                
                // Aktualisiere abh√§ngige Werte
                if (slotType === 'armor') {
                    calculateArmorClass();
                }
                updateWeaponsTable();
                updateAllStats();
                saveCharacterData();
            } catch(e) {
                console.error('Fehler beim Anlegen:', e);
                document.querySelectorAll('.dragging').forEach(el => el.classList.remove('dragging'));
                draggedItemElement = null;
            }
        }

        // Hilfsfunktion zum Erstellen von Inventar-Item-Elementen
        function createInventoryItemElement(item) {
            const itemElement = document.createElement('div');
            itemElement.className = 'inventory-item';
            itemElement.setAttribute('draggable', 'true');
            itemElement.setAttribute('ondragstart', 'dragItem(event)');
            itemElement.setAttribute('data-item', JSON.stringify(item));
            if (item.id) {
                itemElement.setAttribute('data-item-id', item.id);
            }
            
            const icon = item.type === 'armor' ? 'üõ°Ô∏è' : '‚öîÔ∏è';
            itemElement.innerHTML = `
                <span>${icon} ${item.name}</span>
                <div class="item-controls">
                    <button class="btn-remove" onclick="removeInventoryItem(this, 'equipment')">√ó</button>
                </div>
            `;
            return itemElement;
        }

        function unequipItem(slotId) {
            const slotItemElement = document.getElementById(slotId + 'Item');
            if (slotItemElement.classList.contains('slot-item')) {
                const itemData = slotItemElement.getAttribute('data-item');
                
                // F√ºge Item zur√ºck ins Inventar ein
                if (itemData) {
                    try {
                        const item = JSON.parse(itemData);
                        const equipmentList = document.getElementById('equipmentList');
                        const returnItem = createInventoryItemElement(item);
                        equipmentList.appendChild(returnItem);
                        
                        // Wenn 2h-Waffe, reaktiviere offhand Slot
                        if (item.hands === '2h') {
                            const offHandSlotContainer = document.getElementById('offHandSlot');
                            if (offHandSlotContainer) {
                                offHandSlotContainer.style.opacity = '1';
                                offHandSlotContainer.style.pointerEvents = 'auto';
                                offHandSlotContainer.removeAttribute('data-disabled');
                            }
                        }
                    } catch(e) {
                        console.error('Fehler beim Ablegen:', e);
                    }
                }
                
                // Entferne Item aus Slot
                slotItemElement.className = 'slot-placeholder';
                slotItemElement.innerText = slotId === 'armorSlot' ? 'Keine R√ºstung' : 'Leer';
                slotItemElement.removeAttribute('data-item');
                slotItemElement.onclick = null;
                
                // Aktualisiere Abh√§ngigkeiten
                if (slotId === 'armorSlot') {
                    calculateArmorClass();
                }
                updateWeaponsTable();
                updateAllStats();
                saveCharacterData();
            } else {
                // Slot ist leer - zeige verf√ºgbare Items
                showAvailableItemsForSlot(slotId);
            }
        }
        
        // Zeige verf√ºgbare Items f√ºr einen Slot als Dropdown
        function showAvailableItemsForSlot(slotId) {
            const slotType = document.getElementById(slotId).getAttribute('data-slot');
            const equipmentList = document.getElementById('equipmentList');
            const selectId = slotId + 'Select';
            const select = document.getElementById(selectId);
            
            if (!select) return;
            
            // L√∂sche alte Optionen (au√üer der ersten)
            select.innerHTML = '<option value="">-- ' + (slotType === 'armor' ? 'Keine R√ºstung' : 'Keine Waffe') + ' --</option>';
            
            const availableItems = [];
            
            equipmentList.querySelectorAll('.inventory-item').forEach(item => {
                const itemData = item.getAttribute('data-item');
                if (itemData) {
                    try {
                        const itemObj = JSON.parse(itemData);
                        
                        if (slotType === 'armor' && itemObj.type === 'armor') {
                            availableItems.push({element: item, data: itemObj});
                        } else if ((slotType === 'mainhand' || slotType === 'offhand') && itemObj.type === 'weapon') {
                            // Pr√ºfe ob Waffe f√ºr Slot geeignet ist
                            if (slotType === 'offhand' && itemObj.hands === '2h') {
                                return; // 2h-Waffen nicht f√ºr offhand
                            }
                            availableItems.push({element: item, data: itemObj});
                        }
                    } catch(e) {
                        // Ignoriere fehlerhafte Items
                    }
                }
            });
            
            // F√ºge Optionen zum Dropdown hinzu
            availableItems.forEach((item, index) => {
                const option = document.createElement('option');
                option.value = JSON.stringify({element: item.element, data: item.data});
                option.textContent = item.data.name;
                select.appendChild(option);
            });
            
            // Zeige Dropdown
            select.style.display = 'block';
            select.focus();
        }
        
        // Item aus Dropdown ausr√ºsten
        function equipItemFromSelect(slotId, selectedValue) {
            if (!selectedValue) {
                // Leere Auswahl - unequip
                unequipItem(slotId);
                const select = document.getElementById(slotId + 'Select');
                if (select) select.style.display = 'none';
                return;
            }
            
            try {
                const itemInfo = JSON.parse(selectedValue);
                const itemData = itemInfo.data;
                const itemElement = itemInfo.element;
                
                const slotItemElement = document.getElementById(slotId + 'Item');
                const slotType = document.getElementById(slotId).getAttribute('data-slot');
                
                // Pr√ºfe ob Item f√ºr Slot geeignet ist
                if (slotType === 'armor' && itemData.type !== 'armor') {
                    customAlert('Nur R√ºstung kann hier angelegt werden!');
                    return;
                }
                if ((slotType === 'mainhand' || slotType === 'offhand') && itemData.type !== 'weapon') {
                    customAlert('Nur Waffen k√∂nnen hier angelegt werden!');
                    return;
                }
                
                // Pr√ºfe ob Item bereits ausger√ºstet ist
                if (itemElement && itemElement.parentNode) {
                    // Entferne Item aus Inventar
                    itemElement.remove();
                }
                
                // Setze Item in Slot
                slotItemElement.className = 'slot-item';
                slotItemElement.innerText = itemData.name;
                slotItemElement.setAttribute('data-item', JSON.stringify(itemData));
                
                // Behandle 2h-Waffen
                if (itemData.hands === '2h') {
                    const offHandSlotContainer = document.getElementById('offHandSlot');
                    const offHandSlotItem = document.getElementById('offHandSlotItem');
                    if (offHandSlotContainer && offHandSlotItem && offHandSlotItem.classList.contains('slot-item')) {
                        // Wenn offhand Item vorhanden, zur√ºck ins Inventar
                        const offHandData = offHandSlotItem.getAttribute('data-item');
                        if (offHandData) {
                            try {
                                const offHandItem = JSON.parse(offHandData);
                                const equipmentList = document.getElementById('equipmentList');
                                const returnItem = createInventoryItemElement(offHandItem);
                                equipmentList.appendChild(returnItem);
                            } catch(e) {
                                console.error('Fehler beim Zur√ºckgeben:', e);
                            }
                        }
                        offHandSlotItem.className = 'slot-placeholder';
                        offHandSlotItem.innerText = 'Leer';
                        offHandSlotItem.removeAttribute('data-item');
                    }
                    if (offHandSlotContainer) {
                        offHandSlotContainer.style.opacity = '0.5';
                        offHandSlotContainer.style.pointerEvents = 'none';
                        offHandSlotContainer.setAttribute('data-disabled', 'true');
                    }
                } else {
                    const offHandSlotContainer = document.getElementById('offHandSlot');
                    if (offHandSlotContainer && slotId === 'mainHandSlot') {
                        offHandSlotContainer.style.opacity = '1';
                        offHandSlotContainer.style.pointerEvents = 'auto';
                        offHandSlotContainer.removeAttribute('data-disabled');
                    }
                }
                
                // Aktualisiere Abh√§ngigkeiten
                if (slotType === 'armor') {
                    calculateArmorClass();
                } else {
                    updateWeaponsTable();
                }
                
                // Verstecke Dropdown
                const select = document.getElementById(slotId + 'Select');
                if (select) {
                    select.style.display = 'none';
                    select.value = '';
                }
                
                // Speichere und aktualisiere Stats
                updateAllStats();
                saveCharacterData();
            } catch(e) {
                console.error('Fehler beim Ausr√ºsten:', e);
                customAlert('Fehler beim Ausr√ºsten des Items!');
            }
        }
        
        // Slot anklickbar machen - wird im window.load initialisiert

        function equipItem(itemElement, type) {
            // Kann per Klick angelegt werden, wenn Slot leer ist
            // Wird hier durch Drag & Drop gehandhabt
        }

        // Update Bardic Inspiration im Kampfbereich
        function updateBardicInspirationCombat() {
            const currentBI = parseInt(document.getElementById('currentBI').innerText) || 0;
            const biCombatDisplay = document.getElementById('currentBICombat');
            const biButton = document.getElementById('bardicInspirationBtn');
            
            if (biCombatDisplay) {
                biCombatDisplay.innerText = currentBI;
            }
            
            if (biButton) {
                biButton.disabled = currentBI <= 0;
            }
        }

        // Bardische Inspiration verwenden (Bonusaktion)
        async function useBardicInspiration() {
            const currentBI = parseInt(document.getElementById('currentBI').innerText) || 0;
            
            if (currentBI <= 0) {
                await customAlert('Keine Bardische Inspiration mehr verf√ºgbar!');
                return;
            }
            
            const confirmed = await customConfirm('Bardische Inspiration verwenden? (W6 als Bonusaktion)');
            if (confirmed) {
                adjustBI(-1);
                updateBardicInspirationCombat();
                updateAllStats();
                saveCharacterData();
                await customAlert('Bardische Inspiration wurde gegeben! Ziele erh√§lt W6 Bonus auf n√§chsten F√§higkeitswurf, Angriffswurf oder Rettungswurf.');
            }
        }

        // Zauber wirken (pr√ºft Slots)
        function castSpell(button) {
            const spellItem = button.closest('.combat-spell-item');
            const spellType = spellItem.getAttribute('data-spell-type');
            const spellName = spellItem.getAttribute('data-spell-name');
            
            // Zaubertricks ben√∂tigen keine Slots
            if (spellType === 'cantrip') {
                customAlert(`${spellName} wurde gewirkt! (Zaubertrick - keine Slots n√∂tig)`);
                return;
            }
            
            // Pr√ºfe verf√ºgbare Slots
            const usedSlots = document.querySelectorAll('.spell-slot.used').length;
            const totalSlots = document.querySelectorAll('.spell-slot').length;
            const availableSlots = totalSlots - usedSlots;
            
            if (spellType === 'bonus') {
                // Bonusaktion-Zauber (1. Grad)
                if (availableSlots <= 0) {
                    customAlert('Keine Zauberpl√§tze mehr verf√ºgbar!');
                    return;
                }
                
                customConfirm(`${spellName} als BONUSAKTION wirken? (Verbraucht 1 Zauberplatz 1. Grad)`).then(confirmed => {
                    if (confirmed) {
                        // Markiere ersten verf√ºgbaren Slot als verwendet
                        const slots = document.querySelectorAll('.spell-slot');
                        for (let slot of slots) {
                            if (!slot.classList.contains('used')) {
                                slot.classList.add('used');
                                break;
                            }
                        }
                        updateSpellButtons();
                        updateAllStats();
                        saveCharacterData();
                        customAlert(`${spellName} wurde gewirkt! (Bonusaktion)`);
                    }
                });
            } else if (spellType === '1') {
                // 1. Grad Zauber (normale Aktion)
                if (availableSlots <= 0) {
                    customAlert('Keine Zauberpl√§tze mehr verf√ºgbar!');
                    return;
                }
                
                customConfirm(`${spellName} wirken? (Verbraucht 1 Zauberplatz 1. Grad)`).then(confirmed => {
                    if (confirmed) {
                        // Markiere ersten verf√ºgbaren Slot als verwendet
                        const slots = document.querySelectorAll('.spell-slot');
                        for (let slot of slots) {
                            if (!slot.classList.contains('used')) {
                                slot.classList.add('used');
                                break;
                            }
                        }
                        updateSpellButtons();
                        updateAllStats();
                        saveCharacterData();
                        customAlert(`${spellName} wurde gewirkt!`);
                    }
                });
            }
        }

        // Update Spell Buttons basierend auf verf√ºgbaren Slots
        function updateSpellButtons() {
            const usedSlots = document.querySelectorAll('.spell-slot.used').length;
            const totalSlots = document.querySelectorAll('.spell-slot').length;
            const availableSlots = totalSlots - usedSlots;
            
            // Deaktiviere Zauber-Buttons wenn keine Slots verf√ºgbar
            document.querySelectorAll('.combat-spell-item[data-spell-type="1"], .combat-spell-item[data-spell-type="bonus"]').forEach(spellItem => {
                const button = spellItem.querySelector('.btn-cast-spell');
                if (button) {
                    button.disabled = availableSlots <= 0;
                    if (availableSlots <= 0) {
                        button.title = 'Keine Zauberpl√§tze verf√ºgbar!';
                    }
                }
            });
        }

        // Update Weapons Table - jetzt √ºber EquipmentManager
        function updateWeaponsTable() {
            const equipmentManager = new EquipmentManager();
            equipmentManager.updateWeaponsTable();
        }

        // Alte Funktion entfernt - wird durch EquipmentManager ersetzt
        function _oldUpdateWeaponsTable() {
            const mainHandSlot = document.getElementById('mainHandSlotItem');
            const offHandSlot = document.getElementById('offHandSlotItem');
            const mainHandRow = document.getElementById('mainHandWeapon');
            const offHandRow = document.getElementById('offHandWeapon');
            
            // Hauptwaffe
            if (mainHandSlot && mainHandSlot.classList.contains('slot-item')) {
                try {
                    const itemData = mainHandSlot.getAttribute('data-item');
                    const item = JSON.parse(itemData);
                    const name = item.name;
                    const toHit = item.toHit || '+4';
                    const damage = item.damage || '1d4+2';
                    const range = item.range || '1,5m';
                    
                    mainHandRow.innerHTML = `
                        <td>${name} (Haupthand)</td>
                        <td>${toHit}</td>
                        <td>${damage}</td>
                        <td>${range}</td>
                    `;
                } catch(e) {
                    mainHandRow.innerHTML = `<td>-</td><td>-</td><td>-</td><td>-</td>`;
                }
            } else {
                mainHandRow.innerHTML = `<td>-</td><td>-</td><td>-</td><td>-</td>`;
            }
            
            // Nebenhandwaffe
            if (offHandSlot && offHandSlot.classList.contains('slot-item')) {
                try {
                    const itemData = offHandSlot.getAttribute('data-item');
                    const item = JSON.parse(itemData);
                    const name = item.name;
                    const toHit = item.toHit || '+4';
                    // Verwende offhandDamage wenn vorhanden, sonst normales damage
                    const damage = item.offhandDamage || item.damage || '1d4';
                    const range = item.range || '1,5m';
                    
                    offHandRow.style.display = '';
                    offHandRow.innerHTML = `
                        <td>${name} (Nebenhand)</td>
                        <td>${toHit}</td>
                        <td>${damage}</td>
                        <td>${range}</td>
                    `;
                } catch(e) {
                    offHandRow.style.display = 'none';
                    offHandRow.innerHTML = `<td>-</td><td>-</td><td>-</td><td>-</td>`;
                }
            } else {
                offHandRow.style.display = 'none';
                offHandRow.innerHTML = `<td>-</td><td>-</td><td>-</td><td>-</td>`;
            }
        }

        // Modal-Funktionen f√ºr neue Ausr√ºstung
        function showAddEquipmentModal() {
            const modal = document.getElementById('equipmentModal');
            modal.classList.add('active');
            updateEquipmentForm();
        }

        function closeEquipmentModal() {
            const modal = document.getElementById('equipmentModal');
            modal.classList.remove('active');
            // Formular zur√ºcksetzen
            document.getElementById('equipmentForm').reset();
            updateEquipmentForm();
        }

        function updateEquipmentForm() {
            const itemType = document.getElementById('modalItemType').value;
            const weaponFields = document.getElementById('weaponFields');
            const armorFields = document.getElementById('armorFields');
            const offhandDamageGroup = document.getElementById('offhandDamageGroup');
            const lightCheckbox = document.getElementById('modalWeaponLight');
            
            if (itemType === 'weapon') {
                weaponFields.style.display = 'block';
                armorFields.style.display = 'none';
                
                // Zeige/Verstecke offhandDamage basierend auf "light" Checkbox
                if (lightCheckbox && offhandDamageGroup) {
                    offhandDamageGroup.style.display = lightCheckbox.checked ? 'block' : 'none';
                }
            } else {
                weaponFields.style.display = 'none';
                armorFields.style.display = 'block';
                if (offhandDamageGroup) {
                    offhandDamageGroup.style.display = 'none';
                }
            }
        }

        // Event Listener f√ºr "light" Checkbox (einmalig beim Laden)
        document.addEventListener('DOMContentLoaded', function() {
            const lightCheckbox = document.getElementById('modalWeaponLight');
            const offhandDamageGroup = document.getElementById('offhandDamageGroup');
            
            if (lightCheckbox && offhandDamageGroup) {
                lightCheckbox.addEventListener('change', function() {
                    offhandDamageGroup.style.display = this.checked ? 'block' : 'none';
                });
            }
        });

        function addEquipmentFromForm(event) {
            event.preventDefault();
            
            const itemName = document.getElementById('modalItemName').value.trim();
            const itemType = document.getElementById('modalItemType').value;
            
            if (!itemName) {
                customAlert('Bitte gib einen Namen ein!');
                return;
            }
            
            let itemData = {
                name: itemName,
                type: itemType,
                id: itemType + '_' + Date.now()
            };
            
            if (itemType === 'weapon') {
                itemData.slot = document.getElementById('modalWeaponSlot').value;
                itemData.combatType = document.getElementById('modalWeaponCombatType').value || 'melee';
                itemData.hands = document.getElementById('modalWeaponHands').value || '1h';
                itemData.damage = document.getElementById('modalWeaponDamage').value.trim() || '1d4+2';
                itemData.toHit = document.getElementById('modalWeaponToHit').value.trim() || '+4';
                itemData.range = document.getElementById('modalWeaponRange').value.trim() || '1,5m';
                itemData.light = document.getElementById('modalWeaponLight').checked;
                
                if (itemData.light) {
                    itemData.offhandDamage = document.getElementById('modalWeaponOffhandDamage').value.trim() || '1d4';
                }
            } else if (itemType === 'armor') {
                itemData.ac = document.getElementById('modalArmorAC').value || '11';
                itemData.dexBonus = document.getElementById('modalArmorDexBonus').checked;
                if (itemData.dexBonus) {
                    itemData.maxDexBonus = parseInt(document.getElementById('modalArmorMaxDex').value) || 5;
                }
            }
            
            // F√ºge Item ins Inventar ein
            const equipmentList = document.getElementById('equipmentList');
            const newItem = createInventoryItemElement(itemData);
            equipmentList.appendChild(newItem);
            
            // Schlie√üe Modal und speichere
            closeEquipmentModal();
            saveCharacterData();
        }

        // Schlie√üe Modal beim Klick au√üerhalb
        window.addEventListener('click', function(event) {
            const modal = document.getElementById('equipmentModal');
            if (event.target === modal) {
                closeEquipmentModal();
            }
        });

        // Inventory Management nach Kategorien
        function addInventoryItem(category) {
            let inputId, listId;
            switch(category) {
                case 'equipment':
                    inputId = 'newEquipmentInput';
                    listId = 'equipmentList';
                    break;
                case 'consumables':
                    inputId = 'newConsumableInput';
                    listId = 'consumablesList';
                    break;
                case 'tools':
                    inputId = 'newToolInput';
                    listId = 'toolsList';
                    break;
                default:
                    return;
            }
            
            const input = document.getElementById(inputId);
            const itemName = input.value.trim();
            
            if (itemName) {
                const list = document.getElementById(listId);
                const newItem = document.createElement('div');
                newItem.className = 'inventory-item';
                
                // Mappe category zu type f√ºr Datenbank
                // category: 'equipment', 'consumables', 'tools', 'treasure'
                // type: 'equipment', 'consumable', 'tool', 'treasure'
                let itemType = 'equipment';
                if (category === 'consumables') itemType = 'consumable';
                else if (category === 'tools') itemType = 'tool';
                else if (category === 'treasure') itemType = 'treasure';
                else if (category === 'equipment') itemType = 'equipment';
                
                if (category === 'equipment') {
                    newItem.setAttribute('draggable', 'true');
                    newItem.setAttribute('ondragstart', 'dragItem(event)');
                    newItem.setAttribute('data-item', JSON.stringify({name: itemName, type: itemType, category: category}));
                } else {
                    newItem.setAttribute('data-item', JSON.stringify({name: itemName, type: itemType, category: category}));
                }
                
                newItem.innerHTML = `
                    <span>${itemName}</span>
                    <div class="item-controls">
                        <button class="btn-remove" onclick="removeInventoryItem(this, '${category}')">√ó</button>
                    </div>
                `;
                list.appendChild(newItem);
                input.value = '';
                saveCharacterData();
            }
        }

        async function removeInventoryItem(btn, category) {
            const confirmed = await customConfirm('Gegenstand wirklich entfernen?');
            if (confirmed) {
                btn.closest('.inventory-item').remove();
                saveCharacterData();
            }
        }

        // Treasure Management
        function addTreasureItem() {
            const nameInput = document.getElementById('newTreasureName');
            const valueInput = document.getElementById('newTreasureValue');
            const name = nameInput.value.trim();
            const value = valueInput.value.trim();
            
            if (name && value) {
                const list = document.getElementById('treasureList');
                const newItem = document.createElement('div');
                newItem.className = 'treasure-item';
                newItem.setAttribute('data-item', JSON.stringify({name: name, value: value, type: 'treasure', category: 'treasure'}));
                newItem.setAttribute('draggable', 'false');
                newItem.innerHTML = `
                    <span>${name}</span>
                    <span class="treasure-value">${value}</span>
                    <button class="btn-remove" onclick="removeTreasureItem(this)">√ó</button>
                `;
                list.appendChild(newItem);
                nameInput.value = '';
                valueInput.value = '';
                saveCharacterData();
            }
        }

        async function removeTreasureItem(btn) {
            const confirmed = await customConfirm('Wertgegenstand wirklich entfernen?');
            if (confirmed) {
                btn.closest('.treasure-item').remove();
                saveCharacterData();
            }
        }

        // Alte Funktionen (f√ºr Kompatibilit√§t)
        function removeItem(btn) {
            removeInventoryItem(btn, 'tools');
            saveCharacterData();
        }

        function addItem() {
            addInventoryItem('tools');
            saveCharacterData();
        }

        // Speichersystem - JSON-basierte Datenspeicherung
        // Wrapper-Funktionen f√ºr Kompatibilit√§t mit bestehendem Code
        function saveCharacterData() {
            // Verwende aktuellen Character Manager falls verf√ºgbar
            // Pr√ºfe zuerst window.currentCharacterManager (von main.js)
            const manager = window.currentCharacterManager || currentCharacterManager;
            
            if (manager && typeof manager.save === 'function') {
                console.log('Speichere mit currentCharacterManager...');
                manager.save().catch(err => {
                    console.error('‚ùå API-Speichern fehlgeschlagen:', err);
                    console.warn('Wechsle zu localStorage:', err);
                    if (typeof characterDataManager !== 'undefined') {
                        characterDataManager.save();
                    }
                });
            } else {
                // Fallback zu localStorage
                if (typeof characterDataManager !== 'undefined') {
                    console.warn('Verwende localStorage (currentCharacterManager nicht verf√ºgbar)');
                    characterDataManager.save();
                } else {
                    console.error('‚ùå Kein Speicher-Mechanismus verf√ºgbar! currentCharacterManager:', manager, 'characterDataManager:', typeof characterDataManager);
                }
            }
        }

        function loadCharacterData() {
            if (typeof characterDataManager !== 'undefined') {
                return characterDataManager.load();
            } else {
                console.error('CharacterDataManager nicht initialisiert!');
                return false;
            }
        }

        // Wrapper-Funktionen f√ºr Equipment
        function getSlotData(slotId) {
            const equipmentManager = new EquipmentManager();
            return equipmentManager.getSlotData(slotId);
        }

        function setSlotData(slotId, itemData) {
            const equipmentManager = new EquipmentManager();
            equipmentManager.setSlotData(slotId, itemData);
            saveCharacterData();
        }

        // Wrapper-Funktionen f√ºr Inventory
        function getInventoryItems(listId) {
            const inventoryManager = new InventoryManager();
            return inventoryManager.getItems(listId);
        }

        function restoreInventoryItems(listId, items) {
            const inventoryManager = new InventoryManager();
            inventoryManager.restoreItems(listId, items);
        }

        function getTreasureItems() {
            const inventoryManager = new InventoryManager();
            return inventoryManager.getTreasureItems();
        }

        function restoreTreasureItems(items) {
            const inventoryManager = new InventoryManager();
            inventoryManager.restoreTreasureItems(items);
        }

        // Wrapper-Funktionen f√ºr Spell Slots
        function getSpellSlots() {
            const spellSlotManager = new SpellSlotManager();
            return spellSlotManager.getSlots();
        }

        function restoreSpellSlots(slots) {
            const spellSlotManager = new SpellSlotManager();
            spellSlotManager.restoreSlots(slots);
        }

        // Wrapper-Funktionen f√ºr Death Saves
        function getDeathSaves() {
            return characterDataManager.getDeathSaves();
        }

        function restoreDeathSaves(saves) {
            characterDataManager.restoreDeathSaves(saves);
        }

        // Load saved data on page load
        // HINWEIS: Wird jetzt von main.js √ºber DOMContentLoaded gehandhabt
        // Initialisiere Event-Listener wenn DOM bereit ist
        document.addEventListener('DOMContentLoaded', function() {
            console.log('DOMContentLoaded - Initialisiere Event-Listener...');
            
            // Speichere bei √Ñnderungen von editierbaren Feldern
            const currentHPEl = document.getElementById('currentHP');
            if (currentHPEl) {
                currentHPEl.addEventListener('input', function() {
                    if (typeof saveCharacterData === 'function') {
                        saveCharacterData();
                    }
                });
            }

            const currentBIEl = document.getElementById('currentBI');
            if (currentBIEl) {
                currentBIEl.addEventListener('input', function() {
                    if (typeof saveCharacterData === 'function') {
                        saveCharacterData();
                    }
                });
            }

            const currentXPEl = document.getElementById('currentXP');
            if (currentXPEl) {
                currentXPEl.addEventListener('input', function() {
                    if (typeof updateXPBar === 'function') {
                        updateXPBar();
                    }
                    if (typeof checkLevelUp === 'function') {
                        checkLevelUp(parseInt(this.innerText));
                    }
                    if (typeof saveCharacterData === 'function') {
                        saveCharacterData();
                    }
                });
            }
            
            // Speichere bei Gold-√Ñnderungen
            const gpTrackerEl = document.getElementById('gpTracker');
            if (gpTrackerEl) {
                gpTrackerEl.addEventListener('input', function() {
                    if (typeof saveCharacterData === 'function') {
                        saveCharacterData();
                    }
                });
            }
            
            const spTrackerEl = document.getElementById('spTracker');
            if (spTrackerEl) {
                spTrackerEl.addEventListener('input', function() {
                    if (typeof saveCharacterData === 'function') {
                        saveCharacterData();
                    }
                });
            }
            
            const cpTrackerEl = document.getElementById('cpTracker');
            if (cpTrackerEl) {
                cpTrackerEl.addEventListener('input', function() {
                    if (typeof saveCharacterData === 'function') {
                        saveCharacterData();
                    }
                });
            }
            
            // Save notes to localStorage (verwendet jetzt Speichersystem)
            const adventureNotesEl = document.getElementById('adventureNotes');
            if (adventureNotesEl) {
                adventureNotesEl.addEventListener('input', function() {
                    if (typeof saveCharacterData === 'function') {
                        saveCharacterData();
                    }
                });
            }

            const characterNotesEl = document.getElementById('characterNotes');
            if (characterNotesEl) {
                characterNotesEl.addEventListener('input', function() {
                    if (typeof saveCharacterData === 'function') {
                        saveCharacterData();
                    }
                });
            }

            const performanceNotesEl = document.getElementById('performanceNotes');
            if (performanceNotesEl) {
                performanceNotesEl.addEventListener('input', function() {
                    if (typeof saveCharacterData === 'function') {
                        saveCharacterData();
                    }
                });
            }
            
            // Update Spell Buttons wenn Slots ge√§ndert werden
            document.querySelectorAll('.spell-slot').forEach(slot => {
                slot.addEventListener('click', function() {
                    if (typeof updateSpellButtons === 'function') {
                        setTimeout(updateSpellButtons, 50);
                    }
                });
            });
            
            // Drag & Drop Event Listeners - Entferne drag-over beim Verlassen
            document.querySelectorAll('.slot-container').forEach(slot => {
                slot.addEventListener('dragleave', function(e) {
                    // Nur entfernen wenn wir wirklich den Container verlassen
                    const rect = e.currentTarget.getBoundingClientRect();
                    const x = e.clientX;
                    const y = e.clientY;
                    if (x < rect.left || x > rect.right || y < rect.top || y > rect.bottom) {
                        e.currentTarget.classList.remove('drag-over');
                    }
                });
            });
            
            // Death Save Event Listeners
            document.querySelectorAll('[id^="death"]').forEach(checkbox => {
                checkbox.addEventListener('change', function() {
                    if (typeof saveCharacterData === 'function') {
                        saveCharacterData();
                    }
                });
            });
            
            // Slot anklickbar machen - f√ºge Event-Listener hinzu
            document.querySelectorAll('.slot-container').forEach(slot => {
                // Pr√ºfe ob Event-Listener bereits hinzugef√ºgt wurde
                if (slot.hasAttribute('data-click-listener')) {
                    return;
                }
                slot.setAttribute('data-click-listener', 'true');
                
                // F√ºge Event-Listener hinzu
                slot.addEventListener('click', async function(e) {
                    // Ignoriere wenn auf disabled Slot geklickt wird
                    if (this.getAttribute('data-disabled') === 'true') {
                        return;
                    }
                    
                    // Verhindere Event-Bubbling wenn auf Button geklickt wird
                    if (e.target.tagName === 'BUTTON' || e.target.closest('button')) {
                        return;
                    }
                    
                    // Verhindere Drag-Events beim Start
                    if (e.target.hasAttribute('draggable') && e.target.classList.contains('inventory-item')) {
                        return;
                    }
                    
                    const slotId = this.id;
                    const slotItemElement = document.getElementById(slotId + 'Item');
                    
                    if (slotItemElement) {
                        // Wenn auf Slot-Item geklickt wird, ablegen; wenn auf leeren Slot, Items anzeigen
                        if (slotItemElement.classList.contains('slot-item')) {
                            if (typeof unequipItem === 'function') {
                                unequipItem(slotId);
                            }
                        } else if (slotItemElement.classList.contains('slot-placeholder')) {
                            // Leerer Slot - zeige verf√ºgbare Items als Dropdown
                            if (typeof showAvailableItemsForSlot === 'function') {
                                showAvailableItemsForSlot(slotId);
                            }
                        }
                    }
                });
            });
            
            // Speichere regelm√§√üig (alle 30 Sekunden)
            setInterval(function() {
                if (typeof saveCharacterData === 'function') {
                    saveCharacterData();
                }
            }, 30000);
            
            // Enter key to confirm editable fields
            document.querySelectorAll('.editable').forEach(field => {
                field.addEventListener('keypress', function(e) {
                    if (e.key === 'Enter') {
                        e.preventDefault();
                        this.blur();
                    }
                });
            });

            // Temp HP sync
            const tempHPEl = document.getElementById('tempHP');
            if (tempHPEl) {
                tempHPEl.addEventListener('input', function() {
                    // Synchronisiere mit localStorage wenn gew√ºnscht
                });
            }
        });
    </script>
    
    <!-- API Client f√ºr Backend-Integration (MUSS vor main.js geladen werden) -->
    <script type="module" src="/js/API.js"></script>
    <script type="module" src="/js/main.js"></script>
    <script>
        // Warte bis alle Module geladen sind, dann initialisiere
        window.addEventListener('DOMContentLoaded', async function() {
            console.log('DOMContentLoaded - Initialisiere Character Manager...');
            
            // Lade gespeicherte Audio-Datei
            if (typeof loadSavedAudio === 'function') {
                loadSavedAudio();
            }
            
            // Warte kurz, damit alle Module geladen sind
            await new Promise(resolve => setTimeout(resolve, 100));
            
            // Initialisiere Character Manager
            if (typeof window.initCharacterManager === 'function' && typeof window.loadCharacterList === 'function') {
                const characterId = parseInt(localStorage.getItem('currentCharacterId')) || 1;
                console.log('Initialisiere Character Manager f√ºr ID:', characterId);
                window.initCharacterManager(characterId);
                await window.loadCharacterList();
                
                // Lade initialen Character
                if (typeof window.loadCharacter === 'function') {
                    console.log('Lade Character:', characterId);
                    await window.loadCharacter(characterId);
                    
                    // Sync UI nach dem Laden
                    if (typeof updateBardicInspirationCombat === 'function') {
                        setTimeout(() => updateBardicInspirationCombat(), 200);
                    }
                    if (typeof updateSpellButtons === 'function') {
                        setTimeout(() => updateSpellButtons(), 200);
                    }
                }
                
                // Aktualisiere Session-Status
                if (window.sessionManager && window.sessionManager.updateSessionStatus) {
                    setTimeout(() => window.sessionManager.updateSessionStatus(characterId), 500);
                }
                
                // Erstelle sofortigen Screenshot f√ºr aktuellen Stand
                if (window.createInitialSnapshot) {
                    setTimeout(() => window.createInitialSnapshot(), 1000);
                }
            } else {
                console.error('initCharacterManager oder loadCharacterList nicht verf√ºgbar!');
            }
        });
    </script>
</body>
</html>